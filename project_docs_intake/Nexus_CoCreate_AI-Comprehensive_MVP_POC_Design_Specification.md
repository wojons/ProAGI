## **Nexus CoCreate AI \- Comprehensive MVP/POC Design Specification**

This document outlines the comprehensive requirements and design considerations for a Minimum Viable Product (MVP) / Proof of Concept (POC) of the Nexus CoCreate AI platform. It is based on our detailed discussions and references the provided project documentation, aiming to provide an exhaustive input for the AI tasked with its development. The primary objective is to construct an initial, yet robust and functional, version that allows users to deeply experience and validate the core "agentic AI" capabilities, user interaction paradigms, and foundational architecture of the platform.

**1\. Core Concept & Goal (MVP Focus):**

* Platform – An Agentic AI Ecosystem:  
  Nexus CoCreate AI is envisioned as a sophisticated agentic AI platform, meticulously designed to empower a wide spectrum of users. This includes non-engineers—such as marketers looking to automate content generation, researchers aiming to build custom data analysis tools, or educators developing interactive learning modules—as well as seasoned software developers, from solo indie hackers prototyping new ideas to enterprise teams seeking to accelerate complex development workflows. The platform's core mission is to enable these users to intuitively create, manage, deploy, and run a diverse array of AI-powered applications. These applications are interchangeably referred to as "apps" or "projects" within the ecosystem, reflecting their dual nature as both developmental endeavors and shareable, runnable software artifacts.  
  At the very heart of this platform resides a central AI entity named "Nexus." Nexus is not merely a passive tool but an active, intelligent collaborator serving a multifaceted role:  
  1. **Intelligent Conversational Assistant**: Nexus acts as a proactive, context-aware guide. It assists users through every stage of the application lifecycle: from the initial conceptualization of an idea and the collaborative definition of its requirements, through managing the iterative development process, to deploying the application and troubleshooting any issues that may arise. Nexus will offer suggestions, ask clarifying questions, remember user preferences over time, and provide contextual help tailored to the user's current task and skill level. For example, if a user says, "I want to build an app that helps me write blog posts," Nexus might respond by asking about target audience, desired tone, key topics, and preferred output formats, guiding the user to a more concrete app definition.  
  2. **Application Logic Embodiment**: Crucially, Nexus (or specialized AI agents orchestrated by it, a concept for future expansion) can directly embody and execute the core operational logic of the applications built on the platform. This is a direct implementation of the foundational principles of Ultra-High-Level Programming (UHLP), where the AI effectively "pretends to be code" or functions as a dynamic, adaptive runtime environment. This paradigm aims to abstract away significant layers of traditional software development complexity, such as boilerplate code, intricate API integrations, and low-level infrastructure management.

Users will define application behavior through a combination of high-level natural language descriptions, structured prompts (leveraging the rich prompt engineering capabilities from ClineAGI), potentially declarative workflows (simplified for POC), and by clearly specifying desired outcomes. Nexus then interprets these high-level inputs to orchestrate or directly execute tasks. This might involve generating code snippets on the fly, interacting with a rich ecosystem of internal and external tools (via the Model Context Protocol \- MCPs), managing application state (both persistent and runtime), and handling data transformations or analysis. This approach is designed to significantly lower the barrier to entry for creating sophisticated AI solutions, thereby democratizing access to advanced AI capabilities and fostering a new wave of AI-driven innovation. \[cite: ProAGI/memory-bank/productContext.md, ProAGI/memory-bank/projectbrief.md\]

* Deployment Flexibility (POC Simplification & Future Vision):  
  The long-term vision for Nexus CoCreate AI encompasses robust support for both a Software-as-a-Service (SaaS) offering and a self-hostable open-source version, catering to different user needs and preferences.  
  * **SaaS Version**: This model is intended to provide the easiest and most accessible entry point for users who prefer a managed solution. It would likely feature tiered subscription plans (e.g., free tier with basic features and limited usage, individual pro tier, team/business tier with collaborative features and higher limits). Access to a range of generally available AI models would be provided, potentially with some bundled "free tier" tokens for premium LLMs or specialized services. The platform provider would handle all infrastructure, maintenance, and updates, allowing users to focus solely on creating and using their AI applications.  
  * **Self-Hosted Version**: This option is designed for users and organizations that require maximum control, data sovereignty, and customization. It would allow them to deploy Nexus CoCreate AI on their own private infrastructure (on-premises servers or private cloud instances). Users would have full autonomy over data storage, security configurations (including integration with their own authentication systems or security policies), and resource allocation. They could integrate with their preferred Git providers (e.g., self-hosted GitLab, GitHub Enterprise) or run a completely local Git server. A key feature would be the ability to use local or private AI models without restriction. Admins of self-hosted instances could define granular policies for their users, such as setting resource quotas (CPU, memory, token usage per user/project), curating available toolsets (MCPs), defining default model access, or mandating a "Bring Your Own Key" (BYOK) model for all external AI services.

For the **MVP/POC**, the primary focus is on building a functional core system that is architecturally sound and can later be readily adapted for both these deployment models. The initial build will likely be deployed and tested locally, for instance, using Docker Compose on a developer's machine or a single server. The server environment assumed for the POC would be a standard Linux distribution capable of running Docker.

* User Experience – Intuitive, Conversational, and Adaptive:  
  The paramount goal for the user experience (UX) is to be deeply intuitive, primarily chat-centric, and highly capable of abstracting underlying technical complexities. Users, regardless of their technical background, should feel as though they are collaborating with an intelligent, helpful partner (Nexus) rather than programming a complex machine.  
  * **Chat-centricity**: This means the chat window is not just an add-on but the primary medium for command, control, creation, and learning. It should support persistent context within a project, allowing users to pick up conversations where they left off. Thread management within a project's chat might be a future enhancement, but for POC, a single, continuous project chat log is sufficient.  
  * **Abstraction of Complexity**: For example, if an app needs a specific Python library, a non-technical user might just say, "Nexus, I need my app to be able to read Excel files." Nexus should understand this, identify the appropriate library (e.g., pandas or openpyxl), and handle its inclusion in the app's environment (e.g., by updating a requirements.txt and ensuring the Docker image has it) without the user needing to know about package management. Similarly, if a user wants to connect to a common API, Nexus could guide them through the authentication and MCP tool setup conversationally.  
  * **Adaptive Interface**: The interface should subtly adapt to the user's level of expertise. For novices, it might offer more guided workflows, simpler language, and hide advanced configuration options by default. For power users, it could expose more detailed settings, allow direct manipulation of configuration files (e.g., AppDefinition YAML), and provide access to advanced debugging or performance metrics. This could be achieved through user-selectable modes (e.g., "Beginner Mode," "Advanced Mode") or by Nexus learning user preferences over time.

**2\. User Interface & Interaction (MVP Essentials):**

* Primary Interface – The Nexus Chat Window:  
  The cornerstone of user interaction will be a persistent, context-aware chat window. This is where users engage in natural language conversations with their personalized AI assistant, Nexus. Through this interface, users will:  
  * Define and refine project goals and requirements (e.g., "Nexus, let's start a new project to analyze customer feedback from our support tickets. The main goal is to identify common pain points.").  
  * Request Nexus to perform actions (e.g., "Nexus, create a new app based on the 'Sentiment Analysis' template," "Generate Python code to fetch data from this API endpoint {url}," "Summarize the key findings in the 'research\_notes.md' file," "Run Project Alpha and show me its output.").  
  * Receive guidance, suggestions, and feedback from Nexus (e.g., "Okay, I've created the 'Sentiment Analysis' app. To get started, you'll need to provide an API key for the sentiment analysis service. Would you like me to guide you through that?").  
  * Troubleshoot issues and manage project settings (e.g., "Nexus, Project Alpha seems to be running slow, can you check its logs?" or "Change the default LLM for this project to Claude 3 Sonnet.").  
    The chat interface must support rich interaction. For the MVP/POC, text-based input is primary. However, the architecture should consider future support for multimodal input (e.g., users pasting images for analysis, uploading documents for context, or even voice commands if feasible in later stages). The context awareness means Nexus should remember the current project, recent interactions, and user preferences to make conversations feel natural and efficient.  
* The Canvas – A Dynamic Content Workspace:  
  A versatile "canvas" area will serve as the primary view for displaying and interacting with content generated by apps or Nexus. It's a dynamic workspace that adapts to the type of content being handled. For the MVP/POC, this includes:  
  * **Viewing**:  
    * Text documents (plain text, Markdown with preview).  
    * Source code (with basic syntax highlighting for common languages like Python, JavaScript, YAML, JSON). Features like code folding for JSON/YAML would enhance readability.  
    * Simple image formats (e.g., PNG, JPEG).  
  * **Basic Edits**:  
    * **Text/Code**: Users should be able to make direct text edits within the canvas. For code, while a full IDE experience is out of scope for POC, basic syntax highlighting is essential. Nexus could potentially provide simple auto-completion hints or linting feedback conversationally if the user asks for a review of the code on the canvas.  
    * Images (POC): Simple manipulations such as cropping to a selected area, perhaps basic color adjustments (e.g., brightness/contrast sliders if simple to implement), or markup/annotations (e.g., drawing simple arrows or text overlays to highlight parts of an image when providing feedback to Nexus). The ability to "Save As" a modified version of an image, or save the annotated image, would be valuable.  
      The core principle of the canvas is to provide a visually rich, formatted representation of data, moving beyond plain text outputs, and allowing users to take manual control when needed. It's where the "work" of the app often becomes tangible. A key interaction pattern is for users to open a file (e.g., a Python script, a Markdown document) in the canvas and then, through a clearly identifiable button or a conversational command like "Nexus, look at this file," initiate a discussion with Nexus specifically about that content. Nexus should then be aware of the file being viewed, allowing the user to ask questions ("What does this function do?") or request modifications ("Change the title in this document to 'Q2 Report'"). The context of the active canvas item should be implicitly passed to Nexus.  
* Minimal Screens & Overlays – Focus on Flow:  
  The platform UI should be lean and avoid a proliferation of complex, multi-layered screens or traditional dashboards, especially for the MVP. Most interactions should flow naturally through the primary chat interface and the adaptive canvas. Contextual overlays might appear for specific, focused tasks (e.g., a file version history dropdown when viewing a file, a simple tool configuration pop-up if an MCP tool requires parameters not suitable for chat input, or a confirmation dialog for critical actions). These overlays should be non-intrusive and quickly dismissible, ensuring they don't disrupt the primary conversational and content-focused user experience. The underlying philosophy is that users derive enjoyment and value from what they make and achieve with the platform; the UI's role is to facilitate this creative and productive process with minimal friction and cognitive load.  
* App Management Toolbar (POC Functionality):  
  When an app or project is selected or active (e.g., its content is being viewed on the canvas, or it's the subject of the current chat conversation with Nexus), a simple, contextual toolbar should provide essential, predefined buttons for core lifecycle actions. For the POC, this should include:  
  * **"Start"**: To initiate the execution of the app's defined start script (as specified in its AppDefinition) within its dedicated Docker container.  
  * **"Stop"**: To terminate the running app container.  
  * "Restart": To gracefully stop and then start the app container, effectively reloading it.  
    These actions, when triggered, must provide clear visual feedback in the UI. For example, status indicators next to the app's name could change (e.g., from "Stopped" to "Starting..." to "Running"), button icons might change, or brief toast notifications could confirm the action's initiation and completion.  
* Running App Interaction – Modality-Driven Presentation:  
  The way a user interacts with a "running" app will depend on the nature of the app itself, as defined by its creator. The platform must flexibly accommodate various interaction modalities:  
  * **Conversational/Agentic Apps**: For applications that are primarily dialogue-based (e.g., a custom Q\&A chatbot, a research assistant agent, an interactive personality test), these will typically run using the **same agentic chat interface** the user is already familiar with for interacting with Nexus. However, when the specific app is "running," Nexus (or the agent instance embodying the app) operates strictly based on the prompts, logic, tools, and functions defined specifically for *that application*. It's as if Nexus adopts the "persona," knowledge base, and operational parameters of the running app. There should be a clear visual cue to the user indicating that they are now interacting with the "running app" persona versus the general "Nexus assistant" persona.  
  * **Web-based Apps (POC Simplification)**: If the app created by the user is a website or a web application (e.g., a simple static site generated by Nexus, or a dynamic web app with its own backend logic), the POC should provide a straightforward way to display and interact with it. This could be an embedded view (e.g., using an iframe within a dedicated panel on the canvas) or by opening the app in a new browser tab. The AppDefinition might include a field specifying the app's output type or preferred display method. The app itself might have its own internal UI and interaction elements (including its own chat interface, if it was designed that way by its creator). Security considerations for iframes (like sandboxing attributes) should be kept in mind even for the POC if this route is taken.  
  * **CLI-based Apps (POC Simplification)**: If the user's app is designed as a command-line tool or script, the platform should provide a basic "dummy shell" or a text-based terminal-like interface. This interface would allow users to type commands or provide input to the CLI app and see its textual output, all happening within the app's running Docker container. This could be a panel on the canvas. Basic features like command history within this dummy shell would be a plus.  
* Switching Context Between App and Nexus:  
  Users must have a clear and intuitive mechanism to switch their interaction focus between a live, running application and engaging with the overarching Nexus assistant for broader platform commands, project management tasks (e.g., stopping the current app, viewing its logs, modifying its AppDefinition), or working on entirely different projects.  
  * **Embedded Apps**: If an application runs within an embedded view (such as an iframe or a dedicated panel on the canvas), the primary Nexus chat window and the project management toolbar should ideally remain visible and accessible within the main platform UI. This allows the user to seamlessly shift their focus – for example, they could be interacting with their web app in one panel and simultaneously ask Nexus a question about its performance in the chat window. Clear visual delineation between the app's embedded UI and the platform's UI is important.  
  * **Separate Tab/Window Apps**: If an application, by its nature (e.g., a standard website), opens in a new browser tab or window, the user would use standard browser navigation (switching tabs) to return to the original Nexus CoCreate AI platform tab. This original platform tab then effectively serves as the "control panel" or "admin view" for that project, where they can interact with Nexus or use the project toolbar for management tasks. The platform could provide a clear "Return to Project Management" button or link if an app is launched externally.

**3\. Project/App Lifecycle (MVP Core Functionality):**

* **Creation – User-Friendly Initiation**:  
  * A prominent, easily discoverable "+" button (or a similar intuitive UI element like "Create New Project") will be the entry point for users to initiate the creation of a new project/app.  
  * Upon clicking this button, users will be presented with clear and concise options to bootstrap their project:  
    * **"Custom Project"**: For the MVP, selecting this option will start the user with a very minimal, predefined boilerplate or template. This template would contain the bare essentials for an AppDefinition (e.g., a placeholder for the project name, a single primary prompt area for defining the app's core logic, and perhaps a default LLM selection). This allows users to start from a nearly blank slate but with the necessary underlying structure.  
    * **"Project Template" (POC Simplification)**: To demonstrate the concept of reusable starting points and accelerate app creation, the MVP should offer 1 or 2 very simple, pre-existing templates. Examples could include:  
      * A "Basic Q\&A Bot" template: This might include a prompt asking the user to provide a knowledge source (e.g., paste text, upload a document in future iterations) and another prompt for defining the bot's persona or answering style.  
      * A "Simple Web Page Generator" template: This might prompt the user for the page title, main content, and desired color scheme, then generate a basic HTML page.  
        These templates would provide a slightly more structured starting point and showcase different application types.  
  * After selecting an option, the user will be prompted by Nexus (via the chat interface) to provide a name for their new project and a brief natural language description of its purpose or the desired outcome. Nexus can then engage in a short, guided conversational dialogue to elicit key initial requirements or clarify the user's intent (e.g., "What kind of tasks will this app perform?" or "Who is the target audience for this Q\&A bot?"). However, the user must always have a clear option to skip this extended dialogue (e.g., by saying "Just create the project" or clicking a "Skip for now" button) and proceed directly to the project workspace with the minimal information provided.  
* Storage (POC – Local Git Focus):  
  A fundamental architectural principle is that all projects, including their AppDefinition, configuration files, prompts, generated code, and associated assets, are stored as Git repositories. This approach inherently provides robust version control, detailed history tracking, the ability to roll back changes, and a solid foundation for future features like branching, merging, and collaborative development.  
  * For the MVP/POC, the system will manage these as **local Git repositories** on the server where the Nexus CoCreate AI platform is running. The complexities of integrating with external Git providers (like GitHub, GitLab, Bitbucket) or allowing users to specify their own remote Git server URLs can be deferred to post-POC development. The StateManagerInterface component of the Core Framework will be responsible for abstracting and handling all interactions with these local Git repositories (e.g., initializing new repos, committing changes, reading files, retrieving version history).  
* **Interaction with Nexus during Design & Development**:  
  * Users will primarily provide feedback, iterate on designs, request code generation or modifications, and define application logic by conversing with Nexus through the main chat interface. This conversational interaction is central to the UHLP paradigm.  
  * While advanced feedback mechanisms (e.g., star ratings for responses, emoji reactions, detailed UI markups on canvas elements) are envisioned for a richer user experience, for the POC, clear **text-based feedback and requests** to Nexus are sufficient (e.g., "Nexus, that's not quite right, try rephrasing the introduction," or "Generate a Python function that takes X and returns Y").  
  * Nexus's general personality and interaction style (e.g., verbosity, tone, proactivity) can be influenced by a basic set of user-configurable rules. For the POC, this could be a simplified version of the Cline rules concept, perhaps allowing the user to choose from a few predefined personality profiles or set a verbosity level. However, it's critical that when Nexus is operating within the context of a specific project, the project's own defined rules, prompts, and the overall AppDefinition will take precedence in dictating Nexus's behavior and the application's operational logic, ensuring project-specific instructions are correctly followed.  
* App Definition (AppDefinition) (MVP Simplification):  
  The AppDefinition serves as the core specification and "source of truth" for any app or project within the platform. It's a structured representation (likely YAML, managed in Git) of all aspects of the application. For the MVP, a minimal AppDefinition must include at least the following essential fields:  
  * A unique name (and an internal appId) for the project.  
  * The core prompt(s) that define the app's primary function or behavior. This could be a single detailed prompt for simple apps, or a reference to a very simple, predefined workflow (e.g., a sequence of 2-3 prompts).  
  * The specific LLM (Large Language Model) to be used for the app's execution (e.g., "openai/gpt-3.5-turbo," "anthropic/claude-3-sonnet"). This allows apps to leverage different models based on their needs.  
  * Crucially, as part of the UHLP and self-defining system principles, the AI (Nexus itself, or an AI component invoked during app setup or modification) should define the necessary **operational scripts** (e.g., a "start" script command, potentially a "health check" command for future use) required to run the application correctly within its Docker container environment. This script path or command will be stored as part of the AppDefinition (e.g., under a runtime.scripts.start field) and will be used by the SandboxManager to launch and manage the app.  
* **App Execution – Dockerized Sandboxes**:  
  * User actions such as "Start" or "Restart" (triggered via the project toolbar or by issuing a conversational command to Nexus) will instruct the Core Framework to execute the AI-defined operational scripts associated with that specific app.  
  * These scripts are executed within the app's dedicated **Docker container** (referred to as a "sandbox"). This containerization provides isolation, environment consistency, and resource management. The SandboxManager component of the Core Framework is responsible for orchestrating these operations, including pulling the necessary Docker image (which could be a generic base image for the POC, equipped with runtimes like Python and Node.js), mounting project files, and running the specified scripts.  
  * Once started, apps (meaning their Docker containers) will remain active in the background, capable of processing requests or performing ongoing tasks, until they are explicitly stopped by the user. This allows for persistent services or agents.  
* **Stopping Apps – Clear Control & State Handling**:  
  * Users can stop their running apps at any time, either via the "Stop" button on the project toolbar or by issuing a conversational command to Nexus (e.g., "Nexus, please stop Project Alpha").  
  * The UI must provide clear and immediate feedback that the "stop" command has been initiated and then successfully completed. This could involve updating a status indicator for the app (e.g., changing from "Running" in green to "Stopping..." in yellow, then to "Stopped" in red or grey) and possibly displaying a brief notification message.  
  * For the POC, when an app is stopped, its immediate, non-persistent runtime state *within* the Docker container (e.g., in-memory variables of the running process, temporary files not explicitly saved to the Git repo) is typically discarded. A subsequent "Start" command will initiate a fresh launch of the container image based on its AppDefinition and the files in its Git repository. Any data that the application was designed to save persistently (e.g., by instructing Nexus to commit changes to files in its Git repository, or by interacting with an external database if configured) will, of course, remain available. This simplifies state management for the initial POC.  
* Version Control & Rollbacks (POC Essentials – Git Powered):  
  The Git-backed nature of projects is central to providing robust versioning and rollback capabilities.  
  * Users must be able to request rollbacks of changes by conversing with Nexus. For example, they might say: "Nexus, revert the last change made to the 'main.py' file in Project Gamma," or "Nexus, show me the previous versions of this 'config.yaml' document."  
  * The canvas interface, when viewing a file that is part of the Git repository, should feature a simple dropdown menu (or a similar intuitive UI element). This menu will allow users to see a list of previous versions (commits) of that specific file, with commit messages and timestamps, pulled directly from its Git history. Selecting a version from this list should display its content, and there should be an option to "Revert to this version."  
  * The MVP should robustly support the ability to roll back a **single file** to a selected previous version. This involves Nexus (via the StateManagerInterface) checking out the old version of the file and committing it as a new change, effectively undoing subsequent modifications to that file.  
  * Full project-level rollbacks (reverting all project files and configurations to a specific past commit point) can be considered a later enhancement if it introduces significant complexity for the initial POC, but the underlying Git infrastructure supports this.  
  * A basic "track changes" or visual diff view within the canvas to compare the current version of a file with a selected previous version (or the last committed version) would be highly beneficial for users to understand changes before reverting. If a full visual diff is too complex for the POC, at least showing the content of the selected older version alongside the current one would be helpful. The core functionality is the ability to *access* historical versions and *revert to* them.

**4\. Configuration & API Keys (MVP Simplification):**

* BYOK (Bring Your Own Key) – Core Principle for Flexibility and Cost Control:  
  A key design principle for Nexus CoCreate AI is to provide users with flexibility and control over costs associated with using third-party AI models and services. The BYOK model is central to this. Users should be able to provide their own API keys for various LLMs (e.g., OpenAI, Anthropic, Google Gemini, Cohere) and potentially other external services that their applications might need to integrate with (e.g., image generation APIs, data source APIs). For the POC, focus should be on supporting BYOK for at least one or two major LLM providers.  
* Management via Nexus – Conversational Control for Ease of Use:  
  Consistent with the chat-centric UI, users will primarily manage these API keys and other essential application configurations conversationally through their Nexus assistant. This avoids the need for users to navigate complex settings pages. Example interactions:  
  * User: "Nexus, I need to add my OpenAI API key for Project Alpha." Nexus: "Okay, please paste your OpenAI API key here. I'll make sure it's stored securely for Project Alpha."  
  * User: "Nexus, which LLM API key is currently active for the 'Researcher' app?" Nexus: "The 'Researcher' app is currently using an Anthropic API key."  
  * User: "Nexus, can you update the API key for the Google Gemini model I'm using in Project Beta? Here's the new key: {new\_key}."  
  * User: "Nexus, please remove the Twitter API key from my global settings."  
* Storage (POC Security – Simplified but Mindful of User Experience):  
  For the MVP/POC, the primary focus is on achieving functional key management. Robust, enterprise-grade secret management solutions (e.g., integration with HashiCorp Vault, Azure Key Vault, AWS Secrets Manager) are important post-POC goals.  
  * **Storage Options for POC**:  
    1. API keys can be stored in simple, dedicated configuration files (e.g., a secrets.yaml or .env file) within the project's specific Git repository. These files should ideally be added to the project's .gitignore by default if they are intended to be truly local to the user's instance and not committed to a shared remote, or handled with Git-crypt or similar if they must be in the repo but encrypted. For a purely local POC, storing them in a file within the project repo that is *not* typically shared might be the simplest path.  
    2. Alternatively, keys could be managed as environment variables that are securely injected into the application's specific sandbox (Docker container) at runtime by the SandboxManager. This keeps them out of the versioned file system.  
  * **Crucially, for User Experience and Basic Security Hygiene**: Even with simplified backend storage for the POC, Nexus **must mask the API key input** in the chat interface when the user is providing it (e.g., displaying asterisks or dots instead of the actual characters). The key should also not be echoed back in plain text in subsequent messages. This prevents accidental shoulder-surfing or exposure in chat logs.  
* Dependency Resolution for Cloned/Shared Apps – Guided Configuration:  
  If a user installs or clones an app from a template or a shared source, and that app requires specific API keys to function (as would be defined in its AppDefinition's configSchemaJson or similar), their Nexus assistant must play an active role in ensuring the app is usable.  
  * Nexus will parse the newly installed app's AppDefinition to identify any missing API key configurations.  
  * It will then conversationally guide the new owner through the process of providing their own keys for those services. For example: "Welcome to the 'Advanced Image Analyzer' app\! To use its core features, you'll need to provide an API key for the 'XYZ Vision Service'. Can you provide that now?"  
  * Nexus could also offer to use a globally configured key if the user has one set up and it's appropriate for the app, or guide them to where they can obtain such a key if they don't have one.

**5\. Sharing (Minimal Viable Sharing for MVP):**

* Basic Link Sharing – Core Mechanism for Distribution:  
  Users must be able to generate a unique, persistent, and shareable link for their created apps/projects. This link is the primary way they will distribute their creations to others. The link should ideally be somewhat human-readable or at least easily copyable.  
* Access for New Users – Simple Onboarding Flow:  
  If a user who does not have an account on the Nexus CoCreate AI platform (or is not currently logged in) accesses a shared app link:  
  * They should be directed to a simple, clean landing page that briefly explains Nexus CoCreate AI and indicates they need to sign up or log in to access the shared app.  
  * For the MVP, a basic email and password signup mechanism is sufficient. Social logins (e.g., "Sign in with Google," "Sign in with GitHub") are a valuable "plus" if they can be straightforwardly implemented for the POC, as they significantly lower the friction for new user acquisition, but they can be deferred if they add too much complexity to the initial build.  
* **Access Control (POC Simplification – Request/Grant Model for Private Apps)**:  
  * When a logged-in user accesses a shared app link for which they do not yet have explicit permissions (and the app is not marked as "fully public"):  
    * They should be presented with a clear message indicating they don't have access and an option to "Request Access" from the app's owner.  
    * The app owner (the user who originally shared the link) should receive a simple notification of this access request. For the MVP, this could be an in-platform message delivered via their Nexus chat window (e.g., "User 'JohnDoe' is requesting access to your app 'MyResearchTool'.") or, if email services are integrated for the POC (e.g., for password resets), an email notification.  
    * The app owner should then be able to grant or deny this access. This could be managed by interacting conversationally with Nexus (e.g., "Nexus, grant JohnDoe access to MyResearchTool") or through a very simple management interface for the app's sharing settings (perhaps a list of pending requests with "Approve" / "Deny" buttons). This model is inspired by the familiar Google Docs sharing request flow.  
* Permission Levels (POC Simplification – Basic Roles for Shared Apps):  
  For the MVP, the focus should be on implementing very basic and distinct permission levels for shared apps:  
  * **"Owner"**: The original creator of the app, having full control over its definition, configuration, sharing settings, and ability to delete it.  
  * "Viewer" / "Can Run": A user who has been granted access can view the app's interface (if it has one) and run/execute the app (e.g., interact with the conversational app, use the CLI app, view the web app). However, they cannot make changes to the app's underlying AppDefinition, prompts, code, or configurations. They also cannot re-share it with others unless explicitly allowed by a future permission.  
    The more granular, prompt-based "limited editing" permissions, where collaborators can make specific types of changes under AI guardrails, represent an advanced feature suitable for post-POC development.

**6\. Technical Backend (MVP Core Components – Lean Implementation):**

* API-Driven Architecture – Foundation for Flexibility:  
  All frontend UI actions (from the chat window, canvas interactions, toolbar clicks) must communicate with a well-defined backend API. This ensures a clean separation of concerns between the frontend and backend logic, facilitates easier testing, and allows for the future development of alternative clients (e.g., a more advanced CLI, mobile apps, or third-party integrations) that can consume the same backend services. For the POC, a RESTful HTTP API or a simple RPC-style API (like gRPC if the team is comfortable) would be suitable. Key API endpoints would be needed for user authentication, project creation/management, app execution control, chat interaction with Nexus, and canvas content operations.  
* Core Framework (Simplified for POC – Essential Services):  
  The backend will be built around a Core Framework providing essential services. For the MVP, these components should be implemented in a lean, functional manner:  
  * **Application Registry (Minimal)**: Its primary role in the POC is to manage a basic AppDefinition for each project. This AppDefinition (likely a YAML file in the project's Git repo) must at least contain: the app's unique name (and an internal appId generated by the system), its core prompt(s) or a reference to a very simple predefined workflow that defines its behavior, the chosen LLM (e.g., model identifier like "openai/gpt-4o-mini"), and the AI-defined start script command/path necessary for execution.  
  * **Sandbox Manager (Docker Focus)**: This component is critical for running the user's apps in isolated environments. For the MVP, it must be able to:  
    * Start Docker containers based on a generic base image. This base image should be pre-configured with necessary runtimes (e.g., Python 3.10+, Node.js LTS) and common libraries that Nexus might use or generate code for.  
    * Reliably stop and restart these containers on demand.  
    * Execute the AI-defined operational scripts (like the "start" script) within the running containers. This could be achieved using docker exec or by having a minimal agent/API endpoint within the base Docker image that the SandboxManager can call.  
  * **Request Router (Minimal)**: This component acts as the initial entry point for many backend requests. For the MVP, it needs to intelligently route incoming user requests from the UI (originating from chat commands, toolbar actions, etc.) to either:  
    1. The correct app's running sandbox if the request is intended for an active application (e.g., user input for a running chat app).  
    2. Nexus's core logic if it's a platform-level command (e.g., "create a new project") or a general request for assistance from Nexus as the AI assistant.  
       The routing logic could be based on URL paths, specific headers, or parameters in the request payload.  
  * **StateManagerInterface (Git-based)**: This service is the sole gateway for interacting with project storage. For the MVP, it must be able to manage project files within **local Git repositories** on the server. Its capabilities must include: reading file contents, writing/updating files (and ensuring these changes are committed to Git with appropriate messages), and retrieving file version history to support the rollback feature. It abstracts the direct Git commands from other parts of the system.  
* Prompts – Foundation from ClineAGI – Strategic Reuse:  
  A significant accelerator for developing Nexus's intelligence and conversational capabilities for the MVP is to leverage and adapt the extensive, detailed prompts that were developed for the prior ClineAGI project. This existing body of work (including .clinerules concepts if adaptable) can form the initial basis for:  
  * Nexus's core conversational intelligence and natural language understanding.  
  * Its ability to guide users through various tasks (like app creation or configuration).  
  * The underlying logic for many of the agentic tasks the platform will perform.  
    The prompt\_inventory.yaml and the LLM Prompt Template YAML format, as described in the Nexus CoCreate AI System Specification, should be utilized to organize, manage, and deploy these adapted prompts effectively. \[cite: ProAGI/memory-bank/web-research.md, spec\_sections/03.18.1\_AgentDefinitionPrompting.md\]  
* Open Source Leverage – Build Smart, Not Hard – Explicit Instruction to Dev AI:  
  The AI responsible for building the POC software should be explicitly instructed and strongly encouraged to utilize existing, mature, and well-maintained open-source libraries for common, non-core functionalities. Reinventing the wheel for standard components is counterproductive for an MVP and can introduce unnecessary bugs and delays. This includes, but is not limited to:  
  * **Docker Interaction**: Libraries like docker-py for Python or equivalent robust libraries in other languages (e.g., Node.js dockerode).  
  * **Git Repository Management**: Libraries like GitPython for Python or simple-git for Node.js to handle Git operations programmatically.  
  * **Backend Web Framework**: A lightweight but capable web framework for building the API server (e.g., FastAPI or Flask for Python; Express.js for Node.js).  
  * **Frontend Framework/Libraries (Optional for POC UI)**: While a very simple UI for the chat and canvas might be achievable with vanilla JavaScript, HTML, and CSS for the POC, if a minimal framework simplifies development (e.g., Svelte, Vue.js for specific components), its use should be considered. The goal is functionality and speed for the MVP.  
  * **Basic Data Handling**: Libraries for JSON/YAML parsing and serialization are standard.

**Out of Scope for Initial MVP/POC (Noted for Future Iterations – To Maintain Focus):**

It's crucial for the MVP/POC to maintain a tight focus on core functionality. The following features, while valuable for the long-term vision, are explicitly **out of scope** for the initial build to ensure timely delivery of a testable product:

* **Advanced Security for API Key Storage**: Full integration with dedicated secret management systems like HashiCorp Vault. (POC uses simpler, masked storage).  
* **Public App Library/Marketplace & Monetization Features**: The community sharing hub, app discovery features beyond basic link sharing, and any payment integrations.  
* **Advanced "Hooks" System**: The sophisticated, user-defined event-driven automation for complex prompt chaining and inter-app communication. (POC relies on simpler prompt sequences or AI-driven direct execution).  
* **Full, Rich In-Canvas Editors**: Comprehensive, specialized editing capabilities for all diverse file types (e.g., a full image editor, a spreadsheet editor with formulas). (POC focuses on basic text/code viewing/editing and very simple image operations).  
* **Complex, User-Defined Multi-Step Workflows**: The visual workflow builder or the ability for users to define intricate multi-step workflows using complex YAML definitions are post-POC. (MVP will rely on very simple predefined internal workflows or single-prompt app logic).  
* **JIT Optimization**: The OptimizationOracle and the dynamic generation of JIT code for performance enhancement are advanced architectural features.  
* **Sophisticated Multi-User Collaboration Features**: Real-time co-editing of files on the canvas, complex role hierarchies beyond basic owner/viewer for sharing, and project team management.  
* **Self-Hosting Full Feature Parity & Admin Controls**: While the architecture should be conducive to self-hosting, the initial POC might focus on a single-instance deployment model. Full administrative controls for self-hosted instances (e.g., managing user token allocations, system-wide model configurations) will be refined in later stages.  
* **Advanced AI Customization & Learning**: Deep personalization of Nexus's core behaviors beyond basic rule sets, and mechanisms for Nexus to learn autonomously from user interactions or feedback in a persistent way.

This expanded and detailed specification should provide a much more comprehensive foundation for the AI to begin the development of the Nexus CoCreate AI MVP/POC. The emphasis remains firmly on delivering a functional core loop: a user should be able to easily define a simple AI-driven application, run it within an isolated Dockerized environment, and interact effectively with both the running application and the Nexus assistant, primarily through an intuitive conversational interface, supported by a basic canvas for content viewing/editing and a simple toolbar for essential application lifecycle management.