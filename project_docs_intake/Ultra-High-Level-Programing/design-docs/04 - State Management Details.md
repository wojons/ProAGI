## 4. State Management Details (Reference: UHLP Document Section III)

State management is a cornerstone of the UHLP framework, providing the context, definitions, configuration, and runtime data necessary for applications to function dynamically and adaptively. This section details the conceptual content of the state, the chosen storage mechanisms for different types of state, and how state is accessed via the internal `StateManagerInterface` API.

### 4.1. Conceptual Content

The state associated with a UHLP application encompasses several distinct categories of information, working together to define and drive its behavior:

*   **`ApplicationDefinition`:** The high-level blueprint of the application. This includes metadata (like `appId`, `displayName`, version), configuration for required sandbox pools (`SandboxPoolConfig`), security settings (`SecurityConfig` including API keys and permissions), optimization rules (`OptimizationConfig`), and overall configuration for state storage (`StateConfig`) [1]. This is typically established during application registration via the `ApplicationRegistry` [1].
*   **`ComponentRegistry`:** A critical piece of the definition state, mapping logical application parts or routes to their specific implementations [1]. It typically defines components by `componentId` and includes details like:
    *   The `handlerType` (`LLM`, `JIT`, `WORKFLOW`) [1].
    *   The `targetPoolName` specifying which sandbox pool executes the component [1].
    *   The specific `taskDetails` required by the handler (e.g., prompt template path, JIT script/function name, `workflowId`) [1].
    *   The `expectedResultFormat` (`generic`, `httpResponse`, `error`) [1].
    *   Routing information (`RouteMatcher`) if the component is triggered via HTTP [1].
    *   Component-specific configuration overrides.
    This registry is the primary lookup source for the `RequestRouter` [1] and is updated by the `OptimizationOracle` when JIT code replaces LLM logic [1].
*   **Workflow Definitions:** Declarative YAML files (as specified in Section 6.1) defining multi-step processes, stored within the definition state (e.g., `workflows/my_workflow.yaml`) [1].
*   **Prompt Templates:** YAML files (as specified in Section 8.1) defining the structure and content of prompts used by `LLM` handler types, stored within the definition state (e.g., `prompts/my_prompt.yaml`) [1].
*   **JIT Code Artifacts:** The actual source code files (e.g., `_jit_code/my_component/v1/handler.py`) and potentially associated test files generated by the `OptimizationOracle`, stored within the definition state [1].
*   **`RuntimeData`:** Ephemeral state information relevant during active request processing or short-term application operation [1]. This includes:
    *   Active session information (if using framework-managed sessions).
    *   Temporary variables or intermediate results passed between steps in a complex workflow.
    *   Short-term caching results (though longer-term caching might use dedicated caching MCPs or persisted state).
    *   Distributed locks (e.g., for coordinating access to shared resources or ensuring state file consistency during updates).
*   **`MCPServersConfig`:** Configuration detailing the available Community and Application-Specific MCP servers, their endpoints, and potentially required credentials or routing rules. This information is likely part of the `ApplicationDefinition` or managed configuration accessed via `ApplicationRegistry` [1].
*   **`PerformanceLog` / Metrics:** While raw performance data is handled by the `MetricCollector`, aggregated summaries or historical performance trends relevant for optimization decisions might conceptually be considered part of the application's broader operational state context, informing the `OptimizationOracle` [1].
*   **`OptimizationDecisions`:** A history or log of optimization actions taken by the `OptimizationOracle` (e.g., which components were JIT-compiled when), potentially stored within the definition state for auditability [1].
*   **Application Domain Data:** Data specific to the application's purpose (e.g., user accounts, blog posts, product inventory). **Crucially, this is NOT typically managed by the framework's core state management system.** It resides in external databases (SQL, NoSQL) or object storage, accessed by sandboxes via dedicated **Community MCP Servers** (e.g., `community.database.postgres`, `community.aws.s3`) [1].

### 4.2. Storage Mechanisms

The UHLP framework employs a hybrid storage strategy, choosing appropriate mechanisms based on the nature and requirements of the state data:

#### 4.2.1. Definition/Config State: Git + YAML Files (Primary Source of Truth)

*   **Mechanism:** For the core application definition, configuration, component registry, workflows, prompts, and generated JIT code, the primary storage mechanism is **text files (primarily YAML)** organized within a directory structure specific to the application. This entire directory structure is managed under **Git version control** [1].
*   **Rationale:**
    *   **Versioning & History:** Git provides robust, built-in version tracking, allowing review of changes, rollbacks, and understanding evolution over time [1].
    *   **Traceability & Audit:** Git history inherently logs who made changes and when [1].
    *   **LLM/Tool Processability:** YAML and code files are easily parsed, analyzed, and modified by both LLMs (e.g., for understanding configuration or performing automated upgrades) and standard development tools [1].
    *   **Atomicity (via Commits):** Git commits provide a mechanism for grouping related state changes atomically.
    *   **Branching/Merging:** Git workflows can be used for developing and testing changes to application definitions in isolation.
*   **Access:** Handled via the file-like methods (`GetDefinitionFileContent`, `ApplyDefinitionDiff`, etc.) on the `StateManagerInterface`, which internally interacts with the Git repository [1].
*   **Git LFS:** For potentially large files (e.g., extensive logs if stored in state, large JIT artifacts - though source code is usually small), Git Large File Storage (LFS) can be utilized if necessary, managed transparently by Git [1].

#### 4.2.2. Runtime Ephemeral State: Redis

*   **Mechanism:** For transient `RuntimeData` requiring fast access and potentially supporting atomic operations (like counters or locks), an in-memory data store, **Redis**, is the designated mechanism [1].
*   **Rationale:**
    *   **Performance:** Redis offers extremely fast read/write operations suitable for session data, caching, and runtime variables.
    *   **Atomic Operations:** Provides commands like `INCRBY`, `SETNX` (for locks) that are crucial for reliable runtime coordination.
    *   **TTL Support:** Built-in Time-To-Live features are ideal for managing the lifecycle of ephemeral data like sessions or cache entries.
*   **Access:** Handled via the key-value methods (`SetRuntimeValue`, `GetRuntimeValue`, etc.) on the `StateManagerInterface`, which interacts with the configured Redis instance [1]. Keys are automatically namespaced per `appId`.

#### 4.2.3. Application Domain Data: External Databases (via MCP)

*   **Mechanism:** Data that constitutes the application's core business information (user content, etc.) resides in standard external databases (e.g., PostgreSQL, MongoDB, managed services like Supabase) or object storage (S3) [1].
*   **Rationale:** Separates the application's operational definition (framework state) from its user-generated or business data. Allows leveraging mature, scalable database technologies.
*   **Access:** Sandboxes **do not** access these databases directly. They use standardized **MCP tools** provided by Community MCP Servers (e.g., `community.database.postgres.query`, `community.aws.s3.getObject`) [1]. These MCP servers manage connections and credentials, providing a layer of abstraction and security.

### 4.3. Access API (Provided by `StateManagerInterface`)

All interactions with both Definition/Config state (Git/YAML) and Runtime state (Redis) by framework components or sandboxes (via Core MCP wrappers) **MUST** go through the **`StateManagerInterface` Internal API** (specified in Section 3.3) [1].

This centralized interface provides:
*   **Abstraction:** Callers don't need to know the specifics of Git commands or Redis protocols [1].
*   **Consistency:** Ensures common mechanisms for locking, error handling, and potentially caching are applied.
*   **Security:** Allows centralized enforcement of access controls based on `appId` or other context if needed in the future.
*   **Maintainability:** Changes to underlying storage mechanisms can be implemented within the `StateManagerInterface` without requiring changes in all calling components.

The key methods provided allow reading file content, applying diffs atomically to configuration files, listing directories, and performing standard key-value operations on the runtime store [1].