## Goal: Implement Placeholder Authorization Hooks

Add placeholder authorization checks in critical code paths (`CoreMCPServer`, Admin API handlers) to establish the pattern, without implementing the full permission logic yet.

**Context:**
*   MCP Server Code: `@mcp_servers/core/server.py`
*   Router Code: `@core/routing/request_router.py`
*   Security Config: `@core/shared/data_models.py` (`SecurityConfig`, `UserRoleDefinition`) - needed conceptually.
*   Design Docs: `08-security.md` [11, 25] (Least Privilege).

**Plan:**

1.  **Define Authorization Helper:**
    *   Add a helper function (e.g., in a new `core/security/auth.py` file or directly within `CoreMCPServer`/`RequestRouter`).
    *   `async def check_permission(user_context: dict, required_permission: str, app_definition: AppDefinition) -> bool:`
        *   For V1, this function *always returns `True`*.
        *   Add logging: `logger.debug(f"Checking permission '{required_permission}' for user '{user_context.get('userId', 'anonymous')}'")`.
        *   Add a `# TODO: Implement actual permission checking logic based on user roles (user_context['roles']), SecurityConfig, and required_permission.` comment inside.
    *   Create `core/security/__init__.py` if needed. Use `write_to_file` for the new file/updates.
2.  **Instrument `CoreMCPServer`:**
    *   Use `read_file` to load `@mcp_servers/core/server.py`.
    *   Import the `check_permission` helper.
    *   Ensure `AppDefinition` can be retrieved (via `app_registry` dependency using `appId` from context).
    *   In the main `handle_mcp_request` function, *before* calling the specific tool handler:
        *   Identify the required permission for the tool (e.g., `core.state.getDefinitionFileContent` -> `uhlp:state:read`, `core.state.setDefinitionFileContent` -> `uhlp:state:write`, `core.linux.executeCommand` -> `uhlp:exec:command`). Define these permissions conceptually.
        *   Extract user/API key context (assume available in `mcp_request['context']` - *add TODO to ensure this context is passed*).
        *   Call `authorized = await check_permission(mcp_request['context'], required_permission, app_def)`.
        *   `if not authorized: raise MCPPermissionDeniedError("...") # Define custom exception`. Handle this specific exception to return a 403 MCP error.
    *   Use `write_to_file` to save changes.
3.  **Instrument Admin API Handlers (`RequestRouter`):**
    *   Use `read_file` to load `@core/routing/request_router.py`.
    *   Import the `check_permission` helper.
    *   In each admin API handler (`handle_list_apps`, `handle_register_app`, etc.), *at the beginning*:
        *   Define the required permission (e.g., `handle_register_app` -> `uhlp:admin:apps:create`).
        *   Extract user context from the request (assume an authentication mechanism adds user info to `request` object - *add TODO for Authentication implementation*).
        *   Call `authorized = await check_permission(user_context, required_permission, None) # AppDefinition might not apply to global admin actions`.
        *   `if not authorized: return web.HTTPForbidden(text="Permission Denied")`.
    *   Use `write_to_file` to save changes.
4.  **Add Tests (Optional - Placeholder Focus):** Add basic tests ensuring the `check_permission` *function is called* in the relevant places (using `AsyncMock.assert_called_once`), even though it always returns `True` for now.

**Expected Outcome:**
*   Placeholder calls to `check_permission` are added at key points in the MCP server and Admin API handlers.
*   A basic `check_permission` function exists (always returning `True`) with TODOs for real implementation.
*   Custom permission denied exceptions/HTTP responses are used.
*   TODOs mark where user context needs to be populated (Authentication) and where actual permission logic needs to reside.