## Goal: Expose Internal Admin APIs via `RequestRouter`

Implement basic HTTP endpoints within the main framework server (`@core/routing/request_router.py`) to allow the Admin Panel (or other internal tools) to interact with the `ApplicationRegistry` service.

**Context:**
*   Router Code: `@core/routing/request_router.py`
*   Registry Interface: `@core/interfaces/application_registry_interface.py` (methods like `list_applications`, `get_application_definition`, `register_application`)
*   Data Models: `@core/shared/data_models.py` (`AppDefinition`)
*   Web Framework: Assumed `aiohttp` based on previous implementation.
*   Project Standards: `@.clinerules`

**Plan:**

1.  **Read Router Code:** Use `read_file` to load `@core/routing/request_router.py`.
2.  **Import Necessary Types:** Ensure `AppDefinition`, `yaml`, `json`, `web`, `ValidationError` (from Pydantic) are imported.
3.  **Implement API Handlers:** Add the following `async` handler functions within the `RequestRouter` class (or as standalone functions registered with the app):
    *   **`handle_list_apps(self, request: web.Request)`:**
        *   Calls `self.app_registry.list_applications()`.
        *   Returns a `web.json_response({"applications": app_ids})`.
        *   Include standard error handling (`try/except`).
    *   **`handle_get_app_definition(self, request: web.Request)`:**
        *   Extract `app_id` from `request.match_info`.
        *   Calls `self.app_registry.get_application_definition(app_id)`.
        *   If found, return `web.json_response(app_def.model_dump(mode='json'))` (use Pydantic's `.model_dump`).
        *   If not found, return `web.HTTPNotFound`.
        *   Include standard error handling.
    *   **`handle_register_app(self, request: web.Request)`:**
        *   Check `Content-Type` (support `application/json` and `application/yaml`).
        *   Parse the request body (use `await request.json()` or `yaml.safe_load(await request.text())`).
        *   Validate and create an `AppDefinition` Pydantic model instance from the parsed data. Catch `ValidationError` and return `web.HTTPBadRequest` with details.
        *   Call `self.app_registry.register_application(app_def)`.
        *   Return `web.json_response(app_def.model_dump(mode='json'), status=201)`.
        *   Include standard error handling (catch `ValueError` for duplicates -> `web.HTTPConflict`).
    *   **(Future Placeholder) Implement Handlers for Update/Deregister:** Add stubs for `handle_update_app` (`PUT /_internal/apps/{app_id}`) and `handle_deregister_app` (`DELETE /_internal/apps/{app_id}`).
4.  **Register Routes:** Inside the `create_router_app` function (or equivalent setup):
    *   Add routes mapping the internal API paths to the implemented handlers:
        *   `app.router.add_get("/_internal/apps", router.handle_list_apps)`
        *   `app.router.add_get("/_internal/apps/{app_id}", router.handle_get_app_definition)`
        *   `app.router.add_post("/_internal/apps", router.handle_register_app)`
        *   Add routes for update/deregister (pointing to stubs).
5.  **Add Basic Tests:** Use `write_to_file` to update `tests/core/routing/test_request_router.py` (or create a new file `tests/core/routing/test_admin_api.py`).
    *   Add tests specifically targeting the `/_internal/apps` endpoints using the `aiohttp` test client.
    *   Mock the `ApplicationRegistryInterface` methods (`list_applications`, `get_application_definition`, `register_application`) to simulate success and error scenarios.
    *   Test correct status codes (200, 201, 400, 404, 409, 500) and response bodies.
6.  **Save Changes:** Use `write_to_file` to save the updated `@core/routing/request_router.py` and the test file.

**Expected Outcome:**
*   The `RequestRouter` server now exposes basic HTTP endpoints (`/_internal/apps/...`) for interacting with the `ApplicationRegistry`.
*   Basic integration tests verify these new endpoints (using mocks).