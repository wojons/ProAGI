## Goal: Refine `core.linux.executeCommand` for Targeted Sandbox Execution

Modify the `handle_linux_execute_command` function in `@mcp_servers/core/server.py` to support executing commands inside a *specific* Docker container identified by ID, as required by the test runner tool (`core.testing.runPytestInSandbox`).

**Context:**
*   MCP Server Code: `@mcp_servers/core/server.py`
*   Required by: `core.testing.runPytestInSandbox` implementation.
*   Dependency: Docker client (`docker` library) potentially needed here, or rely on `SandboxManager` providing an exec capability. Let's assume direct Docker client usage for now.
*   Security Design Doc: `08-security.md` [11, 25] (Security principles still apply, even with `docker exec`).

**Plan:**

1.  **Read Server Code:** Use `read_file` to load `@mcp_servers/core/server.py`.
2.  **Locate Handler:** Find the `async def handle_linux_execute_command(...)`.
3.  **Modify Handler Signature/Input:**
    *   Add an optional `container_id: Optional[str] = None` parameter to the `params` dictionary expected by the tool. Update the input schema (`@mcp_servers/core/schemas/core.linux.executeCommand.input.schema.json`) to reflect this optional parameter.
4.  **Implement Execution Path Logic:**
    *   Inside the handler, check if `container_id` is provided in `params`.
    *   **If `container_id` is present:**
        *   **Validate Target:** Ensure the provided `container_id` is valid and potentially corresponds to a known/managed sandbox (optional check via `SandboxManager` if feasible).
        *   **Whitelist Check:** Perform the command whitelist check as before (must still be done even for `docker exec`).
        *   **Execute via `docker exec`:**
            *   Get the Docker client instance (needs to be available, passed as dependency or globally).
            *   Get the container object: `container = docker_client.containers.get(container_id)`. Handle `DockerNotFound`.
            *   Construct the command list: `full_cmd_list = [command] + args`.
            *   Use `container.exec_run(cmd=full_cmd_list, stream=False, demux=False, user='uhlp_sandbox_user')`. **Crucially use the `user` parameter** to run as the low-privilege user inside the container. Handle potential `APIError`.
            *   Get `exit_code`, `output` (stdout/stderr combined). Decode the output bytes.
            *   Log execution details.
            *   Format and return the response `{ "success": ..., "exitCode": ..., "stdout": output.decode(), "stderr": "", ... }`. Handle non-zero exit codes.
    *   **Else (if `container_id` is NOT present):**
        *   Execute the command using the original `asyncio.create_subprocess_exec` logic (within the MCP server's environment, still as low-priv user, with whitelisting, etc.).
5.  **Refactor Common Logic:** Ensure input validation, whitelisting, and response formatting logic is shared between the two execution paths (local vs. docker exec).
6.  **Update Tests:** Modify tests in `tests/mcp_servers/core/test_server.py` for `executeCommand`:
    *   Add tests specifically for the `docker exec` path, mocking `docker_client.containers.get` and `container.exec_run`.
    *   Ensure existing tests for local execution still pass.
7.  **Save Changes:** Use `write_to_file` to save modifications to `@mcp_servers/core/server.py` and the test file.

**Expected Outcome:**
*   The `core.linux.executeCommand` handler is updated to support targeted execution inside a specific container using `docker exec` when a `container_id` is provided in the `params`.
*   All existing security measures (whitelisting, low-priv user) are maintained for both execution paths.
*   Tests are updated to cover the new execution path.