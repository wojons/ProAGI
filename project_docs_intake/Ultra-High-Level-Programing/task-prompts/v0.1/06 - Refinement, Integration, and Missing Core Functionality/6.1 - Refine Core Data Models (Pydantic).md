## Goal: Refine Core Data Structures using Pydantic

Based on the analysis noting discrepancies between the Python dataclasses and the Protobuf definitions in the design spec, refactor `@core/shared/data_models.py` to use Pydantic `BaseModel` and match the detailed structures defined in the Protobuf specs (Section 3.1.5 [18]).

**Context:**
*   Existing Data Models: `@core/shared/data_models.py`
*   Target Specification: Design Doc Section 3.1.5 ([18] - contains Protobuf definitions for `AppDefinition`, `SandboxPoolConfig`, `ComponentDefinition`, `SecurityConfig`, `OptimizationConfig`, `StateConfig`, `RouteMatcher`, `ResourceLimits`, `ApiKeyDefinition`, `InterAppPermission`, `UserRoleDefinition`, `OptimizationRule`, `MetricCondition`, `HandlerType` Enum, `AppStatus` Enum)
*   Python Standards: `@.clinerules` (`01-core-framework.md` [4])

**Plan:**

1.  **Add Dependency:** Use `execute_command` to ensure `pydantic` is listed in `@requirements.txt` and installed.
2.  **Read Existing File:** Use `read_file` to load `@core/shared/data_models.py`.
3.  **Refactor to Pydantic:**
    *   Modify the file to use `pydantic.BaseModel` instead of `dataclasses.dataclass` for all defined models.
    *   Import necessary types (`List`, `Dict`, `Optional`, `Enum`, `Any`) from `typing` and `pydantic`. Import `BaseModel`, `Field` from `pydantic`.
    *   **Update Models:** Carefully review the Protobuf definitions in Design Doc Section 3.1.5 [18] and update/create the Pydantic models in `@core/shared/data_models.py` to match *exactly*. This includes:
        *   `ResourceLimits`
        *   `PoolDefinition`
        *   `SandboxPoolConfig`
        *   `StateConfig`
        *   `RouteMatcher`
        *   `HandlerType` (as `str`, using `typing.Literal` or `pydantic.conliteral` if strict enum values needed during parsing, or `enum.Enum` as base class)
        *   `ComponentDefinition` (ensure `taskDetails` and `configurationOverrides` map correctly)
        *   `ApiKeyDefinition` (use `keyHash`, not raw key)
        *   `InterAppPermission`
        *   `UserRoleDefinition`
        *   `SecurityConfig`
        *   `MetricCondition`
        *   `OptimizationAction` (as Enum or Literal)
        *   `OptimizationRule`
        *   `OptimizationConfig`
        *   `AppStatus` (as Enum or Literal)
        *   `AppDefinition` (ensure all fields from spec are included)
    *   **Nested Structures:** Implement nested structures accurately (e.g., `SandboxPoolConfig` contains a `List[PoolDefinition]`).
    *   **Type Hinting:** Use precise Python type hints (`str`, `int`, `bool`, `Optional[...]`, `List[...]`, `Dict[str, Any]`, `Dict[str, str]`, etc.). Use `pydantic.Field` for default values or validation rules if needed (e.g., `Field(default_factory=list)` for optional lists).
    *   **Validation:** For fields like paths or specific patterns, consider adding basic Pydantic validation using `Field`.
4.  **Update Docstrings:** Add/update Pydantic-compatible docstrings explaining each model and field.
5.  **Save Changes:** Use `write_to_file` to save the updated `@core/shared/data_models.py`.

**Expected Outcome:**
*   `@core/shared/data_models.py` refactored to use Pydantic, accurately reflecting the fields and nested structures defined in the design spec Section 3.1.5 [18].
*   `@requirements.txt` includes `pydantic`.