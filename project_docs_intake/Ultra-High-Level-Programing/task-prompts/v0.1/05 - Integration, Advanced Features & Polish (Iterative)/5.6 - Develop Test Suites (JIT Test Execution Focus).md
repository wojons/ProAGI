## Goal: Integrate JIT Test Execution into Optimization Flow

Modify the `OptimizationOracle` to invoke a process (via MCP) that executes the generated unit tests for newly created JIT code *before* updating the application state to activate the JIT component.

**Context:**
*   Oracle Code: `@core/optimization/optimization_oracle.py` (Specifically the `_trigger_jit_generation` method)
*   Testing Standards: `09-testing.md` [12], `07-jit-optimization.md` [10] (Mandatory test execution)
*   MCP Tools: Assumes an MCP tool exists or needs to be created, e.g., `core.testing.runPytestInSandbox`. This tool would need access to a sandbox environment similar to the JIT target.
*   Dependencies: `StateManagerInterface`, `mcp_client` within the Oracle.

**Plan:**

1.  **Define Test Runner MCP Tool (Conceptual):**
    *   Assume an MCP tool `core.testing.runPytestInSandbox` exists.
    *   Its `params` would need: `app_id`, `sandbox_image` (or pool type), `test_file_path` (path to `test_handler.py` within app state), potentially `code_under_test_path`.
    *   Its `data` response would indicate success/failure and include pytest output.
2.  **Read Oracle Code:** Use `read_file` to get the content of `@core/optimization/optimization_oracle.py`.
3.  **Locate JIT Deployment Point:** Find the section within the `_trigger_jit_generation` method *after* the JIT code and tests have been successfully saved using `state_manager.set_definition_file_content`, but *before* the `ComponentRegistry` is updated.
4.  **Implement Test Execution Step:** Insert the following logic at the location identified above:
    *   **Prepare MCP Call:**
        *   Get the path to the saved test file (e.g., `test_file_path = f"_jit_code/{component_id}/v{N}/test_handler.py"`).
        *   Determine the appropriate sandbox image/pool to use for testing (should match the JIT target environment).
        *   Construct the `params` for the `core.testing.runPytestInSandbox` tool.
    *   **Invoke Test Runner via MCP:**
        *   Use `mcp_client.call_tool("core.testing.runPytestInSandbox", params, context={...})`.
    *   **Process Test Results:**
        *   Check the response from the MCP tool. If it indicates test failure (e.g., `data['success'] == False` or specific error fields):
            *   Log the test failure, including output if available.
            *   **CRITICAL:** Do *not* proceed to update the `ComponentRegistry`. Potentially implement rollback logic (e.g., delete the saved JIT artifacts using `state_manager`) or mark the JIT artifact version as failed.
            *   Return `False` or raise an exception to indicate optimization failed.
        *   If tests pass:
            *   Log test success.
            *   Proceed to the next step (updating the `ComponentRegistry`).
5.  **Adjust State Update Logic:** Ensure the state update logic (modifying and saving `ComponentRegistry`) only runs if the test execution step succeeds.
6.  **Save Changes:** Use `write_to_file` to save the modified content back to `@core/optimization/optimization_oracle.py`.
7.  **(Self-Correction/Future Task):** Recognize that the `core.testing.runPytestInSandbox` MCP tool itself needs to be implemented. This tool would likely: use `SandboxManager` to get a sandbox, copy/mount the test file and code, execute `pytest` inside via `core.linux.executeCommand` (carefully!), and parse the results.

**Expected Outcome:**
*   The `_trigger_jit_generation` method in `@core/optimization/optimization_oracle.py` is updated to include a step that calls a (conceptual) MCP tool to run tests after generating JIT code.
*   The logic prevents activation of the JIT code if the tests fail.