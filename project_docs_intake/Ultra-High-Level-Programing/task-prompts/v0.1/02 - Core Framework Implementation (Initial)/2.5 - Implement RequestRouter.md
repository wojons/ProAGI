## Goal: Implement the Core `RequestRouter`

Implement the `RequestRouter` which acts as the main entry point for external requests, routes them to the appropriate application component (via `ApplicationRegistry`), allocates a sandbox (via `SandboxManager`), executes the request in the sandbox, and returns the response. Based on Section 2.3 [15].

**Context:**
*   `ApplicationRegistryInterface`: `@core/interfaces/application_registry_interface.py`
*   `SandboxManager`: `@core/sandbox/sandbox_manager.py` (The implementation class)
*   Sandbox API Schema: `@schemas/sandbox_execute_request.schema.json`, `@schemas/sandbox_execute_response.schema.json`
*   Design Docs: Section 2.3 [15], Section 2.4 [15] (Sandbox API)
*   Project Standards: `@.clinerules` (async, logging, error handling)

**Plan:**

1.  **Add Dependencies:** Use `execute_command` to add an async HTTP client library like `aiohttp` or `httpx` to `requirements.txt` and install.
2.  **Create Implementation File:** Use `write_to_file` to create `core/routing/request_router.py`.
3.  **Import Dependencies:** Import `aiohttp` (server and client) or `FastAPI` and `httpx`, `logging`, `uuid`, `ApplicationRegistryInterface`, `SandboxManager`, data models, schema definitions.
4.  **Define `RequestRouter` Class (or Functions):** Structure this as a class or potentially as request handler functions within your chosen web framework (e.g., `aiohttp.web` or `FastAPI`). Let's assume a class structure initially.
    *   **Initialization (`__init__`)**:
        *   Accept `ApplicationRegistryInterface` and `SandboxManager` instances as dependencies.
        *   Initialize an `aiohttp.ClientSession` (or `httpx.AsyncClient`) for making requests to sandboxes.
        *   Initialize a logger compliant with `.clinerules`.
    *   **Main Request Handler (`handle_incoming_request`)**:
        *   Define an `async` function that acts as the entry point for your web server (e.g., bound to routes like `/{app_id}/{path:.*}`).
        *   Extract relevant details from the incoming HTTP request (method, path, headers, body, query params). Generate a unique `requestId` (e.g., `uuid.uuid4()`).
        *   **Resolve Component:** Call `self.app_registry.resolve_trigger_to_component(app_id, trigger_details={...})` to find the target `ComponentDefinition` based on the request path/method. Handle component not found errors (return appropriate HTTP error, e.g., 404).
        *   Log the identified component (`componentId`, `handlerType`).
        *   **Allocate Sandbox:** Call `self.sandbox_manager.allocate_sandbox(app_id, component.targetPoolName)` to get details of an available sandbox instance (e.g., IP/port). Handle allocation errors (return HTTP 503 Service Unavailable).
        *   **Prepare Sandbox Request:** Construct the request body for the sandbox's `/execute` endpoint, conforming to `schemas/sandbox_execute_request.schema.json`. Populate `requestData` (map relevant parts of the incoming HTTP request), `context` (include `appId`, `requestId`, `traceId`, `componentId`, `handlerType`, `taskDetails` from component def, `mcp_endpoint`).
        *   **Execute in Sandbox:** Make an `async` `POST` request to the allocated sandbox's `/execute` endpoint (`http://{sandbox_ip}:{sandbox_port}/execute`) using the HTTP client session. Pass the constructed request body. Handle connection errors/timeouts (release sandbox, return HTTP 504 Gateway Timeout or 503).
        *   **Release Sandbox:** Crucially, ensure the sandbox is released using `self.sandbox_manager.release_sandbox(sandbox_details['container_id'])` regardless of success or failure (use `try...finally`).
        *   **Process Sandbox Response:** Parse the JSON response from the sandbox. Validate it against `schemas/sandbox_execute_response.schema.json`. Handle invalid responses (log error, return HTTP 502 Bad Gateway).
        *   **Format Final Response:** Based on the `resultType` and `data` in the sandbox response (and potentially `component.expectedResultFormat`), format the final HTTP response to send back to the original caller. Handle `resultType` == 'error' appropriately (e.g., map to HTTP 500).
        *   Log the outcome and relevant metrics (e.g., total request duration, sandbox execution time from metrics).
        *   Return the final HTTP response object.
    *   **Web Server Integration:** Integrate `handle_incoming_request` into your web server framework (e.g., `aiohttp.web.Application` routes or `FastAPI` endpoints).
5.  **Add Basic Integration Tests:** Use `write_to_file` to create `tests/core/routing/test_request_router.py`.
    *   Use `pytest` and the appropriate test client for your web framework.
    *   Mock `ApplicationRegistryInterface` and `SandboxManager`.
    *   Mock the HTTP client used to call the sandbox (e.g., using `aiohttp.pytest_plugin` fixtures or `httpx` mocking).
    *   Test the end-to-end flow: valid request -> component resolution -> sandbox allocation -> (mocked) sandbox call -> response formatting.
    *   Test error conditions: component not found, sandbox allocation failure, sandbox connection error, sandbox returns error, invalid sandbox response.

**Expected Outcome:**
*   `core/routing/request_router.py` containing the `RequestRouter` implementation integrated with a web server framework.
*   `tests/core/routing/test_request_router.py` containing basic integration tests.
*   Updated dependency file.