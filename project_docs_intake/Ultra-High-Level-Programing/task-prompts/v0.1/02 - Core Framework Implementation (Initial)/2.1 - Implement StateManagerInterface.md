## Goal: Implement the `StateManagerInterface` for Git and Redis

Implement the concrete `StateManager` class which provides access to Definition State (Git/YAML) and Runtime State (Redis), adhering to the `StateManagerInterface` defined in Phase 1 and the details in Section 4 [6, 19] and `04-state-management.md` [6].

**Context:**
*   Interface Definition: `@core/interfaces/state_manager_interface.py`
*   Data Models: `@core/shared/data_models.py`
*   Design Docs: `04-state-management.md` [6], Section 4 [6, 19]
*   Project Standards: `@.clinerules`

**Plan:**

1.  **Add Dependencies:** Use `execute_command` to add necessary libraries to `requirements.txt` (or `pyproject.toml`) and install them:
    *   `GitPython` (for Git interaction)
    *   `redis` (for Redis interaction, use the async version like `redis[asyncio]`)
    *   Ensure libraries required by these (if any) are also captured.
2.  **Create Implementation File:** Use `write_to_file` to create `core/state/state_manager.py`.
3.  **Import Dependencies:** Import `StateManagerInterface` from `@core/interfaces/state_manager_interface.py`, necessary models from `@core/shared/data_models.py`, `GitPython`, `redis.asyncio as redis`, `asyncio`, `os`, `logging`, ABC helpers, etc.
4.  **Define `StateManager` Class:** Create the `StateManager(StateManagerInterface)` class.
    *   **Initialization (`__init__`)**:
        *   Accept configuration parameters: base directory for Git repos (`state_base_path`), Redis connection details (host, port, db).
        *   Initialize a logger instance compliant with `.clinerules` (structured logging).
        *   Initialize the Redis connection pool (`redis.asyncio.BlockingConnectionPool`).
        *   Store configuration.
    *   **Helper Functions (Internal)**:
        *   Implement a private helper `_get_app_repo_path(self, app_id: str) -> str` to construct the path to an app's Git repository (`state_base_path / app_id`).
        *   Implement a private helper `_get_redis_connection(self)` to get a connection from the pool.
        *   Implement private helper `_initialize_git_repo(self, repo_path: str)` if needed for creating repos on the fly (though initial setup might be external).
    *   **Implement Definition State Methods**:
        *   Implement `get_definition_file_content`: Use `GitPython` to open the correct repo, checkout the appropriate branch/commit (consider versioning - default to main branch for V0.1), read the specified file content, handle file not found errors, return bytes. Log the operation. Must be `async`.
        *   Implement `apply_definition_diff`: Use `GitPython` to apply a patch file (diff content), stage changes, commit with the provided message. Handle conflicts/errors. Log the operation. Must be `async`.
        *   Implement `set_definition_file_content`: Use `GitPython` to write the file content to the working directory, stage it, commit with the provided message. Handle errors. Log the operation. Must be `async`.
        *   Implement `delete_definition_file`: Use `GitPython` to remove the file, stage the deletion, commit with the provided message. Handle errors. Log the operation. Must be `async`.
        *   Implement `list_definition_directory`: Use `GitPython` and `os` to list files/dirs within the specified path in the repo. Handle errors. Log the operation. Must be `async`.
    *   **Implement Runtime State Methods**:
        *   Implement `set_runtime_value`: Use the async `redis` client connection to `set` the key (scoped with `app_id`), handle optional TTL. Log the operation. Must be `async`.
        *   Implement `get_runtime_value`: Use the async `redis` client connection to `get` the key (scoped with `app_id`). Handle key not found (return `None`). Log the operation. Must be `async`.
        *   Implement `delete_runtime_value`: Use the async `redis` client connection to `delete` the key (scoped with `app_id`). Log the operation. Must be `async`.
5.  **Add Basic Unit Tests:** Use `write_to_file` to create `tests/core/state/test_state_manager.py`.
    *   Use `pytest` and mocking (`unittest.mock`).
    *   Mock `GitPython` interactions (e.g., `Repo`, `Index`, `Commit` objects and methods).
    *   Mock `redis.asyncio` client interactions.
    *   Write tests for each public method, covering success cases and basic error conditions (e.g., file not found, Redis connection error). Adhere to testing standards in `.clinerules`.

**Expected Outcome:**
*   `core/state/state_manager.py` containing the `StateManager` implementation.
*   `tests/core/state/test_state_manager.py` containing basic unit tests.
*   Updated dependency file (`requirements.txt` or `pyproject.toml`).