## Goal: Implement the `ApplicationRegistry`

Implement the concrete `ApplicationRegistry` class for managing application definitions, adhering to the `ApplicationRegistryInterface` defined in Phase 1 and the specification in Section 3.1 [18]. For V0.1, use in-memory storage possibly backed by the `StateManagerInterface` for persistence loading/saving (though focus on in-memory first).

**Context:**
*   Interface Definition: `@core/interfaces/application_registry_interface.py`
*   Data Models: `@core/shared/data_models.py` (especially `AppDefinition`, `ComponentDefinition`)
*   `StateManagerInterface`: `@core/interfaces/state_manager_interface.py` (for potential persistence later)
*   Design Docs: Section 3.1 [18]
*   Project Standards: `@.clinerules`

**Plan:**

1.  **Create Implementation File:** Use `write_to_file` to create `core/registry/application_registry.py`.
2.  **Import Dependencies:** Import `ApplicationRegistryInterface`, `AppDefinition`, `ComponentDefinition`, `Optional`, `Dict`, `List`, `logging`. Potentially import `StateManagerInterface` if adding persistence hooks now.
3.  **Define `ApplicationRegistry` Class:** Create the `ApplicationRegistry(ApplicationRegistryInterface)` class.
    *   **Initialization (`__init__`)**:
        *   Initialize an in-memory dictionary `_applications: Dict[str, AppDefinition]` to store loaded application definitions.
        *   Initialize a logger compliant with `.clinerules`.
        *   (Optional V0.1+) Accept an instance of `StateManagerInterface` if implementing load/save persistence.
    *   **Implement Interface Methods (In-Memory Focus)**:
        *   Implement `register_application`: Add/update the `app_definition` in the `_applications` dictionary. Log the action. Needs basic validation (e.g., ensure required fields exist). Return `True` on success. (Add persistence call later if needed). Must be `async`.
        *   Implement `deregister_application`: Remove the `app_id` from the `_applications` dictionary. Log the action. Handle `app_id` not found. Return `True` on success. (Add persistence call later if needed). Must be `async`.
        *   Implement `get_application_definition`: Retrieve the `AppDefinition` from `_applications` by `app_id`. Return `None` if not found. Must be `async`.
        *   Implement `update_application_definition`: Similar to `register_application`, update the existing entry. Log the action. Must be `async`.
        *   Implement `list_applications`: Return `list(self._applications.keys())`. Must be `async`.
        *   Implement `get_application_status`: For V0.1, return a simple status like `"Active"` if the app is in memory, or potentially check underlying resource status via `StateManager` in future. Must be `async`.
        *   Implement `get_component_definition`: Retrieve the app definition, then search its `ComponentRegistry` (assuming it's part of `AppDefinition` structure) for the matching `component_id`. Return `None` if app or component not found. Must be `async`.
        *   Implement `resolve_trigger_to_component`: Retrieve the app definition. Iterate through its `ComponentRegistry`. Implement basic logic to match `trigger_details` (e.g., HTTP route/method) against `component.routeMatcher`. Return the first matching `ComponentDefinition` or `None`. Handle different trigger types later. Must be `async`.
4.  **Add Basic Unit Tests:** Use `write_to_file` to create `tests/core/registry/test_application_registry.py`.
    *   Use `pytest`.
    *   Instantiate the `ApplicationRegistry`.
    *   Create mock `AppDefinition` objects.
    *   Test registration, retrieval, update, deletion, listing, and resolving components. Cover edge cases like app/component not found.

**Expected Outcome:**
*   `core/registry/application_registry.py` containing the in-memory `ApplicationRegistry` implementation.
*   `tests/core/registry/test_application_registry.py` containing basic unit tests.