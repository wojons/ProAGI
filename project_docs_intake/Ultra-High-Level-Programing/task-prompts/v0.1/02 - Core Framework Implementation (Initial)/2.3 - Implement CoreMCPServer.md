## Goal: Implement the Basic `CoreMCPServer`

Implement an asynchronous HTTP server that listens for MCP requests, routes them to handlers for core tools (like `core.state.*`), and returns responses according to the MCP specification (Section 5 [20, 7], `07-mcp-standards.md` [7]).

**Context:**
*   Core Tool Schemas: `@mcp_servers/core/schemas/`
*   `StateManagerInterface`: `@core/interfaces/state_manager_interface.py`
*   `ApplicationRegistryInterface`: `@core/interfaces/application_registry_interface.py`
*   API Schemas: `@schemas/mcp_request.schema.json`, `@schemas/mcp_response.schema.json` (Need to create these if not done - defining the overall MCP `{ "tool": "...", "params": {...} }` and response structure `{ "data": {... }}` or `{ "error": {"code": ..., "message": ...} }`)
*   Design Docs: Section 5 [20, 7], Section 3.5 [18] (Core MCP Server), `07-mcp-standards.md` [7], Appendix B [27] (Tool List)
*   Project Standards: `@.clinerules` (async, logging, error handling, JSON)

**Plan:**

1.  **Add Dependencies:** Use `execute_command` to add an async HTTP framework like `aiohttp` or `FastAPI` to `requirements.txt` and install. Also add `jsonschema` for validation.
2.  **Define MCP Request/Response Schemas (If missing):** Use `write_to_file` to create `schemas/mcp_request.schema.json` and `schemas/mcp_response.schema.json` defining the top-level structure of MCP requests and responses (success/error formats).
3.  **Create Server File:** Use `write_to_file` to create `mcp_servers/core/server.py`.
4.  **Import Dependencies:** Import `aiohttp.web` (or `FastAPI`), `json`, `logging`, `jsonschema`, `StateManagerInterface`, `ApplicationRegistryInterface`, core tool schemas (maybe load dynamically).
5.  **Implement Server Structure:**
    *   **Configuration:** Set up loading of host/port configuration (e.g., from environment variables).
    *   **Dependencies:** Set up instantiation of dependencies (`StateManager`, `ApplicationRegistry` - passed in or created).
    *   **Logging:** Initialize structured logger compliant with `.clinerules`.
    *   **Tool Handlers Map:** Create a dictionary mapping tool names (e.g., `"core.state.getDefinitionFileContent"`) to handler functions.
    *   **Main Request Handler (`handle_mcp_request`)**:
        *   Define an `async` function to handle incoming `POST` requests to a specific MCP endpoint (e.g., `/mcp`).
        *   Parse the JSON request body. Validate it against `schemas/mcp_request.schema.json`. Handle parsing/validation errors (return MCP error response).
        *   Extract `tool` name and `params`. Log the incoming request details (tool name, `appId` from params if available).
        *   Look up the handler function in the map based on the `tool` name. Handle unknown tool errors.
        *   Validate the `params` against the specific tool's input schema (`@mcp_servers/core/schemas/TOOL_NAME.input.schema.json`). Handle validation errors.
        *   Call the handler function (`async await handler(params, state_manager, app_registry)`).
        *   Handle exceptions during handler execution (return MCP error response).
        *   On success, validate the handler's result against the tool's output schema (`@mcp_servers/core/schemas/TOOL_NAME.output.schema.json`). Handle validation errors.
        *   Format the successful MCP response using `schemas/mcp_response.schema.json` structure.
        *   Return the `aiohttp.web.json_response` (or FastAPI equivalent).
    *   **Implement Tool Handlers:** Create `async` functions for each core tool (e.g., `handle_get_definition_file_content(params, state_manager, ...)`):
        *   These functions take `params` and dependencies (`state_manager`, `app_registry`) as arguments.
        *   They call the appropriate methods on the dependency instances (e.g., `state_manager.get_definition_file_content(...)`).
        *   They transform the result into the expected output `data` structure defined by the tool's output schema.
        *   Implement handlers for core tools like `core.state.*` (calling `StateManager`), `core.framework.*` (calling `ApplicationRegistry`, logging), `core.llm.generate` (placeholder/mock for V0.1 - maybe just log request), `core.linux.executeCommand` (placeholder/secure stub for V0.1 - log request, maybe return dummy data, emphasizing security concerns from `08-security.md` [11, 25]).
    *   **Server Setup:** Create the `aiohttp.web.Application` (or `FastAPI` app), add the route for the MCP endpoint pointing to `handle_mcp_request`, and set up the runner (`aiohttp.web.run_app`). Add a basic `GET /healthz` endpoint.
6.  **Add Basic Tests:** Use `write_to_file` to create `tests/mcp_servers/core/test_server.py`.
    *   Use `pytest` and `aiohttp.pytest_plugin` (or FastAPI's `TestClient`).
    *   Mock `StateManager` and `ApplicationRegistry`.
    *   Test the main request handler: successful calls, unknown tool, invalid request/params format, handler exceptions.
    *   Test individual handlers (if complexity warrants) by calling them directly with mock dependencies.

**Expected Outcome:**
*   `mcp_servers/core/server.py` containing the MCP server implementation.
*   `tests/mcp_servers/core/test_server.py` containing basic unit/integration tests.
*   Potentially `schemas/mcp_request.schema.json`, `schemas/mcp_response.schema.json`.
*   Updated dependency file.