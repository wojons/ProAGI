# Task 8.3: Implement Permission Checking Logic

**Goal:** Implement the *actual* permission checking logic within the `check_permission` function in `@core/security/auth.py`.

**Context:**
- Auth Helper: `@core/security/auth.py`
- Data Models: `@core/shared/data_models.py` (esp. `AppDefinition`, `SecurityConfig`, `ApiKeyDefinition`, `UserRoleDefinition`)
- Design Docs: `@.clinerules/08-security.md` [11] (Least Privilege), `@.design-docs/10 - Security Considerations.md` (AuthZ section [11, 25])
- Placeholders: MCP Server (`@mcp_servers/core/server.py`) and Admin API (`@core/routing/request_router.py`) already call `check_permission`.

**Plan:**

1.  **Analyze:** Read `@core/security/auth.py` and the relevant sections of `@.design-docs/10 - Security Considerations.md` [11, 25], `@.clinerules/08-security.md` [11, 25] regarding permissions. Review the `SecurityConfig` structure in `@core/shared/data_models.py`.
2.  **Define Permission Strategy:** Determine the permission resolution logic. Suggested approach:
    *   Identify caller: Check `user_context` for `userId` or `apiKeyHash`.
    *   If `userId`:
        *   Lookup user's roles for the given `app_id` (requires mechanism to get roles, e.g., from `user_context` or via `ApplicationRegistry.GetUserPermissionsForApp`).
        *   Get permissions associated with those roles from `app_definition.security_config.user_roles`.
    *   If `apiKeyHash`:
        *   Lookup the API key definition in `app_definition.security_config.api_keys` by hash.
        *   Get permissions associated with the key.
    *   If neither ID/Key found or not enabled, deny access.
    *   Check if the `required_permission` (or a wildcard like `uhlp:*:*` or `uhlp:admin:*`) is present in the caller's resolved permissions list.
3.  **Implement `check_permission`:** Use `write_to_file` to modify `@core/security/auth.py`.
    *   Replace the `return True` placeholder with the logic defined in Step 2.
    *   Handle missing `app_definition` for global admin permissions (check against a predefined 'superadmin' role/permission if applicable).
    *   Use clear logging for authorized/denied decisions.
4.  **Add Unit Tests:** Use `write_to_file` to create `tests/core/security/test_auth.py`.
    *   Write `pytest` tests for the `check_permission` function.
    *   Create mock `AppDefinition` objects with various `SecurityConfig` setups (roles, API keys, permissions).
    *   Create mock `user_context` dictionaries.
    *   Test scenarios: user with correct role, user with wrong role, valid API key, API key with missing permission, global admin checks, unknown user/key.
    *   Assert `True` or `False` return values.

**Expected Outcome:** The `check_permission` function in `@core/security/auth.py` contains logic to evaluate permissions based on roles/API keys defined in `SecurityConfig`. Unit tests verify this logic.