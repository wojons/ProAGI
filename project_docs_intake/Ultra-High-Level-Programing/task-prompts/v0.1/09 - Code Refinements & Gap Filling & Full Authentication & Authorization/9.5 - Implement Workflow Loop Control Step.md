# Task 9.5: Implement Workflow Loop Control Step

**Goal:** Enhance the workflow engine (`@sandbox_images/python_runner/sandbox_server.py`) to support a basic `loop` control step type.

**Context:**
- Workflow Engine: `@sandbox_images/python_runner/sandbox_server.py` (`_execute_workflow`)
- Workflow Schema: `@schemas/workflow_definition.schema.json`
- Workflow Design: `@.design-docs/06 - Workflow Definition.md` (Future V2 section mentions loop [8, 21]), `@.design-docs/11 - Future Work  V2+ Considerations.md` [1]

**Plan:**

1.  **Define Loop Step Schema:** Mentally (or update schema file later): A `control` step with `subtype: loop` needs:
    *   `inputList`: An expression (JSONPath) defining the list in `workflow_context` to iterate over.
    *   `loopBodyStepId`: The ID of the step to execute for each item in the list.
    *   `iteratorVar`: Optional name for the variable holding the current item within the loop body's context (e.g., `currentItem`). Defaults to `item`.
    *   `indexVar`: Optional name for the variable holding the current index (e.g., `currentIndex`). Defaults to `index`.
2.  **Analyze `_execute_workflow`:** Read the execution loop logic in `@sandbox_images/python_runner/sandbox_server.py`.
3.  **Implement Loop Logic:** Modify the `if/elif/else` block for step execution:
    *   Add `elif step_type == "control" and step_def.get('subtype') == "loop":`.
    *   Inside this block:
        *   Evaluate `step_def['inputList']` using `_evaluate_jsonpath` to get the list to iterate. Handle non-list results as errors.
        *   Get `loopBodyStepId`. Validate it exists in `workflow_def['steps']`.
        *   Get `iteratorVar`, `indexVar` names.
        *   Initialize an empty list `loop_results = []`.
        *   Start a `for index, item in enumerate(list_to_iterate):` loop.
        *   **Crucially:** For each iteration, execute the `loopBodyStepId`. This requires **recursive** or **nested** execution logic.
            *   **Approach 1 (Complex):** Modify `_execute_workflow` to handle nested calls, potentially passing a modified `workflow_context` for the loop body execution (e.g., adding `currentItem` and `currentIndex`). The nested execution would run just the single `loopBodyStepId` and return its result.
            *   **Approach 2 (Simpler V1):** Define that the `loopBodyStepId` itself *must be* a simple `jit`, `llm`, or `mcp` step (not another control flow step like loop/branch). The loop logic directly prepares input and calls the corresponding helper (`_run_jit_script`, `_run_llm_prompt`, or `mcp_client.call_tool`) for the body step, passing the current `item` and `index` merged into the input data.
        *   Append the result (or error) of the loop body execution to `loop_results`.
        *   Handle errors within the loop body execution (log, potentially store error in results, continue or break loop based on config?).
        *   After the loop, set `step_output = loop_results`.
4.  **Update Input Mapping for Body Step:** Ensure the `inputMapping` for the `loopBodyStepId` can reference the `iteratorVar` and `indexVar` (e.g., `$.loopContext.currentItem`). The `_evaluate_jsonpath` function needs the modified context passed to it during loop body execution.
5.  **Add Tests:** Update `@tests/sandbox/test_workflow_engine.py`:
    *   Define mock workflows using the `loop` step.
    *   Test looping over a list, correct execution of the body step for each item, and aggregation of results.
    *   Test access to `currentItem` and `currentIndex` within the loop body's input mapping.
    *   Test handling of empty input lists.

**Expected Outcome:** The workflow engine supports a basic `loop` control step, allowing iteration over lists and execution of a simple body step for each item.