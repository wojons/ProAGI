# Task 9.3: Verify JIT Test Execution Flow

**Goal:** Verify and potentially refine the integration between `OptimizationOracle`, `core.testing.runPytestInSandbox` MCP tool, and the targeted `core.linux.executeCommand` via `docker exec`.

**Context:**
- Oracle: `@core/optimization/optimization_oracle.py` (`_trigger_jit_generation`)
- MCP Server: `@mcp_servers/core/server.py` (`handle_run_pytest_in_sandbox`, `handle_linux_execute_command`)
- Task Links: 5.6 [12, 56], 6.4 [48], 6.5 [49]

**Plan:**

1.  **Analyze `handle_linux_execute_command`:** Read `@mcp_servers/core/server.py`. Confirm the `container_id` parameter is functional and uses `docker_client.containers.get(id).exec_run` with the correct `user` parameter. Ensure error handling for `DockerNotFound` and `APIError` is present.
2.  **Analyze `handle_run_pytest_in_sandbox`:** Read `@mcp_servers/core/server.py`. Verify it correctly:
    *   Allocates a sandbox using `sandbox_manager`.
    *   Constructs the correct *mounted* path for the test file (e.g., `/state/<appId>/<test_file_path>`). **Add a clear comment explaining the assumed mount point.**
    *   Prepares the `pytest` command and args.
    *   Calls `handle_linux_execute_command` *internally*, passing the `container_id` obtained from allocation in the `params`.
    *   Correctly parses the `exitCode` and `output` from the `executeCommand` result.
    *   Releases the sandbox in a `finally` block.
3.  **Analyze `_trigger_jit_generation`:** Read `@core/optimization/optimization_oracle.py`. Verify it:
    *   Correctly identifies the `target_pool_name` for testing.
    *   Calls `core.testing.runPytestInSandbox`.
    *   Correctly checks the `success` field in the response.
    *   Blocks or proceeds with the registry update based on the test result.
4.  **Refine Error Handling/Logging:** Add more specific logging within these functions to trace the flow (e.g., "Calling executeCommand for pytest in container X", "Pytest execution completed with exit code Y"). Ensure errors (allocation fail, exec fail, test fail) are clearly logged and propagated appropriately.
5.  **Write Integration Test (Manual/Simulated):** Since a full integration test requires running Docker and multiple services, write a *detailed plan* for a manual test or update the existing integration test (`test_oracle_integration.py`) to more accurately simulate the interactions:
    *   Configure the `mock_mcp_client` to *not* mock the internal call from `runPytestInSandbox` to `handle_linux_execute_command`.
    *   Ensure the `docker_client` mock is properly injected into the MCP server context for `handle_linux_execute_command`.
    *   Verify the `exec_run` mock on the `docker_client` is called with the correct command, user, and container ID when `runPytestInSandbox` is invoked by the Oracle.
6.  **Apply Changes:** Use `write_to_file` to apply any necessary code refinements for error handling, logging, or parameter passing identified in steps 1-4. Update the integration test plan/code as per step 5.

**Expected Outcome:** Verified and potentially refined code for the JIT test execution flow across the Oracle and MCP Server, with better logging and a plan/mock for integration testing.