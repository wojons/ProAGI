# Task 9.4: Implement User/API Key Identity Resolution

**Goal:** Add logic to the framework entry points (`RequestRouter` for external requests, `CoreMCPServer` for MCP calls) to identify the caller based on credentials (e.g., API Key header, JWT token).

**Context:**
- Router: `@core/routing/request_router.py` (`handle_incoming_request`)
- MCP Server: `@mcp_servers/core/server.py` (`handle_mcp_request`)
- Registry Interface: `@core/interfaces/application_registry_interface.py` (method `ValidateApiKey`)
- Security Design: `@.design-docs/10 - Security Considerations.md` (Sections 10.3, 10.7 [11, 25]), `@.clinerules/08-security.md` [11, 25]
- Data Models: `@core/shared/data_models.py` (`SecurityConfig`, `ApiKeyDefinition`)

**Plan:**

1.  **Analyze `RequestRouter`:** Read `@core/routing/request_router.py` (`handle_incoming_request`).
    *   Identify where to check incoming request headers (e.g., `Authorization: Bearer <key>` or `X-API-Key: <key>`).
    *   If an API key is found:
        *   Call `self.app_registry.ValidateApiKey(apiKey=...)`. **Note:** This method needs implementation in `@core/registry/application_registry.py` including secure hashing (use `werkzeug.security` suggested by context [3])! Add a TODO there.
        *   If valid, store the resolved `appId` (verify it matches path `appId`), `permissions`, and potentially a `caller_type: 'api_key'` in a `caller_context` dictionary.
    *   If a JWT token is found (Future): Add logic to validate JWT (requires JWT library and secret management). Store resolved `userId`, `roles`, `appId`, `permissions`, `caller_type: 'user'` in `caller_context`.
    *   If no valid credentials, set `caller_context = {'id': 'anonymous', 'roles': ['public']}`.
    *   **Pass `caller_context`** to the `check_permission` call (already planned in Task 7.6 placeholder).
    *   Modify the construction of the sandbox `/execute` request payload to include relevant parts of the resolved caller identity (e.g., `userId`, `roles`) in `context.userInfo`.
    *   Use `write_to_file` to update `@core/routing/request_router.py`.
2.  **Analyze `CoreMCPServer`:** Read `@mcp_servers/core/server.py` (`handle_mcp_request`).
    *   The caller identity (`appId`, `requestId`, maybe `userId`/`roles` if initiated by a user request) should *already be present* in the incoming `context` from the Sandbox/Router.
    *   Extract this existing context to be used as the `caller_context` for the `check_permission` call (already planned in Task 7.6 placeholder). No extra validation needed here if trust boundary is between Framework and Sandbox.
3.  **Implement `ValidateApiKey` (in Registry):** Use `write_to_file` to modify `@core/registry/application_registry.py`.
    *   Add `from werkzeug.security import check_password_hash`.
    *   Implement the `ValidateApiKey` method:
        *   Iterate through all registered applications (`self._applications`).
        *   For each app, iterate through `app.security_config.api_keys`.
        *   Hash the provided `apiKey` (inputted to the method) using the *same method and salt configuration* used during registration/storage (TODO: Define hashing strategy!).
        *   Use `check_password_hash(stored_hash, provided_key)` to compare.
        *   If a match is found and the key is enabled, return `isValid=True`, `appId`, and `permissions`.
        *   If no match, return `isValid=False`.
4.  **Add Tests:**
    *   Update tests for `RequestRouter` (`@tests/core/routing/test_request_router.py`) to include requests with/without API keys (mock `ValidateApiKey` response).
    *   Add tests for `ApplicationRegistry.ValidateApiKey` (`@tests/core/registry/test_application_registry.py`) covering key found, not found, disabled key (requires adding `enabled` to `ApiKeyDefinition`). Mock hashing functions.

**Expected Outcome:** `RequestRouter` attempts to identify callers via API keys, calling a (newly implemented) `ValidateApiKey` in the `ApplicationRegistry`. This identity info is passed to permission checks and sandbox context.