## Goal: Implement an MCP Client Helper within the Sandbox

Create a helper class or function within `sandbox_server.py` to simplify making requests from the sandbox to the Core MCP Server.

**Context:**
*   Server File: `@sandbox_images/python_runner/sandbox_server.py`
*   MCP Request/Response Schemas: `@schemas/mcp_request.schema.json`, `@schemas/mcp_response.schema.json`
*   Dependencies: `httpx` from `@sandbox_images/python_runner/requirements.txt`
*   Project Standards: `@.clinerules` (async, logging, error handling)

**Plan:**

1.  **Modify Server File:** Use the `read_file` tool to get the current content of `@sandbox_images/python_runner/sandbox_server.py`.
2.  **Define `MCPClient` Class:** Add the following class definition within the file:
    ```python
    import httpx
    import logging
    import json
    from typing import Optional, Dict, Any

    logger = logging.getLogger(__name__) # Use existing logger setup

    class MCPClient:
        def __init__(self, mcp_endpoint: str):
            if not mcp_endpoint:
                raise ValueError("MCP Endpoint is required")
            self.endpoint = mcp_endpoint
            # Consider making the client session reusable if performance matters
            # self.client = httpx.AsyncClient()

        async def call_tool(self, tool_name: str, params: Dict[str, Any], context: Dict[str, Any]) -> Dict[str, Any]:
            """Calls an MCP tool and returns the response data or raises an exception."""
            request_payload = {
                "tool": tool_name,
                "params": params,
                # Optionally add context info needed by MCP server security/routing
                "context": {
                     "appId": context.get("appId"),
                     "requestId": context.get("requestId"),
                     "traceId": context.get("traceId"),
                }
            }
            request_id = context.get("requestId", "N/A")
            logger.info(f"[{request_id}] Calling MCP tool: {tool_name}") # Add params logging if not sensitive

            try:
                # Use a context manager for the client session
                async with httpx.AsyncClient() as client:
                    response = await client.post(
                        self.endpoint,
                        json=request_payload,
                        headers={"Content-Type": "application/json"},
                        timeout=30.0 # Add configurable timeout
                    )
                    response.raise_for_status() # Raise exception for 4xx/5xx responses

                response_data = response.json()
                logger.info(f"[{request_id}] MCP tool '{tool_name}' call successful.")

                # Basic validation (more robust would use JSON schema)
                if response_data.get("error"):
                     error_info = response_data["error"]
                     logger.error(f"[{request_id}] MCP tool '{tool_name}' returned error: {error_info}")
                     # Define a custom exception class?
                     raise Exception(f"MCP Error ({error_info.get('code')}): {error_info.get('message')}")
                if "data" not in response_data:
                     logger.error(f"[{request_id}] MCP tool '{tool_name}' response missing 'data' field.")
                     raise Exception("Invalid MCP response format: missing 'data'")

                return response_data["data"]

            except httpx.RequestError as exc:
                logger.error(f"[{request_id}] HTTP error calling MCP tool '{tool_name}': {exc}")
                raise Exception(f"MCP Communication Error: {exc}") from exc
            except json.JSONDecodeError as exc:
                 logger.error(f"[{request_id}] Failed to decode MCP JSON response for tool '{tool_name}': {exc}")
                 raise Exception(f"Invalid MCP Response JSON: {exc}") from exc
            except Exception as exc:
                 logger.error(f"[{request_id}] Error processing MCP call for tool '{tool_name}': {exc}")
                 # Re-raise other exceptions unless specifically handled
                 raise

    ```
3.  **Integrate Client:** Ensure the `/execute` handler in `@sandbox_images/python_runner/sandbox_server.py` initializes this client: `mcp_client = MCPClient(mcp_endpoint)`.
4.  **Save Changes:** Use `write_to_file` to save the modified content back to `@sandbox_images/python_runner/sandbox_server.py`.

**Expected Outcome:**
*   The `@sandbox_images/python_runner/sandbox_server.py` file is updated to include the `MCPClient` class for making reliable calls to the Core MCP server.