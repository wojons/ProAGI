## Goal: Implement JIT Execution Logic (Interpreter Mode) in Sandbox

Add the logic to the `/execute` handler in the sandbox server to handle `handlerType: JIT` requests using the V0.1 Interpreter Mode: fetch the script via MCP, execute it using `subprocess`, and return the result.

**Context:**
*   Server File: `@sandbox_images/python_runner/sandbox_server.py`
*   MCP Client: `MCPClient` class within the server file.
*   Design Docs: Section 7 [10, 22] (JIT Overview), Section 2.4 [15] (Sandbox API), `02-sandbox-api.md` [5]. Focus on V0.1 "Interpreter Mode" [5].
*   Security Guidelines: `08-security.md` [11, 25] (Command Execution risks, need for isolation - though primarily Docker/OS level).

**Plan:**

1.  **Read Server File:** Use `read_file` to get the content of `@sandbox_images/python_runner/sandbox_server.py`.
2.  **Locate JIT Handler Block:** Find the `if request.context.handlerType == "JIT":` block within the `execute` function.
3.  **Implement JIT Logic:** Replace the placeholder logic within the JIT block with the following:
    *   **Extract Task Details:** Get `script_path = request.context.taskDetails.get("script")` and `function_name = request.context.taskDetails.get("function")`. Validate that these exist.
    *   **Fetch Script Content:**
        *   Use the `mcp_client.call_tool` to call `core.state.getDefinitionFileContent` with `params={"app_id": request.context.appId, "file_path": script_path}`.
        *   Handle potential errors from MCP (e.g., file not found).
        *   Decode the base64 content received from MCP.
    *   **Prepare Execution:**
        *   Save the fetched script content to a temporary file within the container (e.g., using `tempfile.NamedTemporaryFile`). Ensure the file has execute permissions if necessary, though we'll invoke `python` directly.
        *   Serialize necessary parts of `request.requestData` and `request.context` into a JSON string to be passed as input to the script (e.g., via stdin or a temporary input file). This needs a defined contract for how JIT scripts receive input. Let's assume passing JSON via stdin for V0.1.
    *   **Execute Script using Subprocess:**
        *   Use `asyncio.create_subprocess_exec` (or `subprocess.run` if blocking is acceptable initially, but prefer async) to run the Python interpreter: `["python", tmp_script_path, function_name]`.
        *   Pass the serialized JSON input via `stdin`.
        *   Capture `stdout`, `stderr`, and the `returncode`. Set a timeout.
    *   **Process Results:**
        *   Check `returncode`. If non-zero, log the `stderr` and return an `ExecuteResponse` with `resultType="application_error"`, including `stderr` in the error details.
        *   If `returncode` is 0, attempt to parse the captured `stdout` as JSON.
        *   If JSON parsing fails, log the error and `stdout`, return `resultType="application_error"`.
        *   If JSON parsing succeeds, this is the result `data`.
    *   **Prepare Success Response:** Construct the `ExecuteResponse` with `resultType="success"` and the parsed JSON data.
    *   **Cleanup:** Ensure temporary files are deleted in a `finally` block.
4.  **Add Imports:** Ensure `subprocess`, `tempfile`, `base64`, `asyncio` are imported.
5.  **Save Changes:** Use `write_to_file` to save the modified content back to `@sandbox_images/python_runner/sandbox_server.py`.

**Expected Outcome:**
*   The JIT handler block in `@sandbox_images/python_runner/sandbox_server.py` is implemented to fetch code via MCP and execute it using the Python interpreter via `subprocess`.