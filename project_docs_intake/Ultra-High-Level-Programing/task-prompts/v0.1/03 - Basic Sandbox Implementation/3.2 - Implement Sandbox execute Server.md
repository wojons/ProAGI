## Goal: Implement the HTTP Server for the Sandbox `/execute` Endpoint

Create the core Python script (`sandbox_server.py`) that runs inside the sandbox container. This script will host an HTTP server (using FastAPI) exposing the `POST /execute` endpoint according to the UHLP specification.

**Context:**
*   Sandbox API Schemas: `@schemas/sandbox_execute_request.schema.json`, `@schemas/sandbox_execute_response.schema.json`
*   API Standards: `02-sandbox-api.md` [5]
*   Directory: `sandbox_images/python_runner/`
*   Dependencies: From `@sandbox_images/python_runner/requirements.txt`
*   Project Standards: `@.clinerules` (async, logging)

**Plan:**

1.  **Create Server File:** Use `write_to_file` to create `sandbox_images/python_runner/sandbox_server.py`.
2.  **Import Dependencies:** Import `FastAPI`, `uvicorn`, `pydantic` (BaseModel), `httpx`, `logging`, `os`, `json`, `subprocess`, `Jinja2`, `uuid`, `datetime`, `Optional`, `Dict`, `Any`.
3.  **Setup Logging:** Configure structured logging compliant with `.clinerules`, capturing standard sandbox context if possible (e.g., reading `UHLP_APP_ID` if passed as env var).
4.  **Define Request/Response Models (Pydantic):**
    *   Define Pydantic models that precisely match the structure defined in `@schemas/sandbox_execute_request.schema.json` (e.g., `ExecuteRequestContext`, `ExecuteRequest`) and `@schemas/sandbox_execute_response.schema.json` (e.g., `ExecuteResponseMetrics`, `ExecuteResponse`). Use nested models for clarity.
5.  **Initialize FastAPI App:** `app = FastAPI()`.
6.  **Implement `/execute` Endpoint:**
    *   Define an `async def execute(request: ExecuteRequest)` function decorated with `@app.post("/execute", response_model=ExecuteResponse)`.
    *   **Log Request:** Log the received request details (`requestId`, `appId`, `componentId`, `handlerType`). Record start time.
    *   **Get MCP Endpoint:** Read `UHLP_MCP_ENDPOINT` from environment variables (or potentially from `request.context.mcp_endpoint` if passed dynamically). Handle missing config.
    *   **Initialize MCP Client:** Create an instance of the MCP client helper (to be defined in the next prompt) `mcp_client = MCPClient(mcp_endpoint)`.
    *   **Handler Logic Placeholder:** Add initial `if/elif/else` block based on `request.context.handlerType` (`LLM`, `JIT`, `WORKFLOW`). For now, these blocks can just log the type and prepare a dummy success response. We will implement the logic in subsequent prompts.
        *   `if request.context.handlerType == "JIT": ...`
        *   `elif request.context.handlerType == "LLM": ...`
        *   `elif request.context.handlerType == "WORKFLOW": ... # Placeholder for Phase 4`
        *   `else: # Handle unknown handler type - return error`
    *   **Error Handling:** Implement a `try...except` block around the handler logic to catch unexpected exceptions. Log errors and format an appropriate `ExecuteResponse` with `resultType="framework_error"` or `application_error`.
    *   **Calculate Metrics:** Calculate basic metrics like `execution_time_ms`.
    *   **Format Response:** Construct the `ExecuteResponse` object (using the Pydantic model) including `requestId`, `resultType`, `data`, and `metrics`.
    *   **Return Response:** Return the `ExecuteResponse` object. FastAPI will serialize it.
7.  **Implement `/healthz` Endpoint:** Add a simple `GET /healthz` endpoint returning `{"status": "ok"}`.
8.  **(Optional) Add Main Execution Block:** Include `if __name__ == "__main__": uvicorn.run(...)` for potential direct execution outside of the Docker CMD.

**Expected Outcome:**
*   `sandbox_images/python_runner/sandbox_server.py` containing the FastAPI server outline, `/execute` and `/healthz` endpoints, Pydantic models for the API contract, basic logging, and placeholders for JIT/LLM logic.