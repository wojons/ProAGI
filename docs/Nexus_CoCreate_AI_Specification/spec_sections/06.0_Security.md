# 6.0 Security Considerations

Security is a paramount concern in the Nexus CoCreate AI platform, given its dynamic nature, reliance on LLMs, execution of JIT code, and interaction with various external tools and data sources. This section outlines key security considerations.

## 6.1 Sandbox Isolation (Docker Dependency Isolation)

*   **V1 Approach (Docker):** Sandboxed Components (JIT runners, LLM orchestrators) are isolated using Docker containers. The primary goal is dependency management and environment consistency.
*   **Limitations:** Docker relies on a shared host kernel. It should not be considered a sufficient boundary against intentionally malicious code in high-security scenarios.
*   **Best Practices:**
    *   Run container processes as non-root users.
    *   Use minimal base images.
    *   Apply resource limits (CPU, memory) via `SandboxManager`.
    *   Restrict container capabilities.
    *   Configure appropriate Docker network policies.
*   **Future Work:** For stronger isolation (e.g., running untrusted code), technologies like Firecracker microVMs should be evaluated.

## 6.2 Secured Command Execution (`core.linux.executeCommand`)

The `core.linux.executeCommand` MCP tool must adhere to a strict security model:
*   **Least Privilege:** Commands execute under a dedicated, low-privilege Linux user account.
*   **Strict Whitelisting:** Execution is restricted to commands on an application-specific whitelist (full paths).
*   **Hardened Wrappers:** For potentially dangerous commands (`curl`, `sed`, `awk`), hardened wrapper scripts sanitize inputs and enforce safe flags. The whitelist points to these wrappers.
*   **No Shell Interpretation:** Avoid shell interpretation to prevent command injection.
*   **Timeouts & Resource Limits:** Strict execution timeouts and resource limits must be applied.

## 6.3 Configuration & API Key Management (MVP Simplification)

### 6.3.1 BYOK (Bring Your Own Key) – Core Principle

A key design principle is to provide users with flexibility and control over costs associated with third-party AI models and services through the BYOK model. Users should be able to provide their own API keys for various LLMs and potentially other external services. For the POC, focus is on supporting BYOK for at least one or two major LLM providers.

### 6.3.2 Management via Nexus – Conversational Control

Users primarily manage API keys and other essential application configurations conversationally through their Nexus assistant. This avoids complex settings pages. Nexus guides the user through providing keys, confirms storage, and can report which keys are active for an app.

### 6.3.3 Storage (POC Security – Simplified but Mindful of User Experience)

For the MVP/POC, robust, enterprise-grade secret management is a post-POC goal.
*   **Storage Options for POC:**
    1.  Store API keys in simple, dedicated configuration files (e.g., `secrets.yaml`, `.env`) within the project's local Git repository. These should ideally be `.gitignore`d or handled with encryption if shared.
    2.  Manage keys as environment variables securely injected into the application's sandbox (Docker container) at runtime by the `SandboxManager`.
*   **User Experience and Basic Security:** Nexus **must mask API key input** in the chat interface (displaying asterisks/dots). The key should not be echoed back in plain text.

### 6.3.4 Dependency Resolution for Cloned/Shared Apps – Guided Configuration

When a user installs or clones an app requiring specific API keys, Nexus actively guides them:
*   Nexus parses the new app's `AppDefinition` to identify missing key configurations.
*   It conversationally guides the user to provide their own keys for those services.
*   Nexus can offer to use a globally configured key if available and appropriate, or guide the user on how to obtain a key.

## 6.4 Inter-App Communication Permissions

*   **Policy Definition:** `AppDefinition` (within `SecurityConfig`) defines rules for which source applications can trigger events/routes in target applications.
*   **Framework Enforcement:** `RequestRouter` or event handlers consult these rules (via `ApplicationRegistryService`) before dispatching cross-app calls.

## 6.5 MCP Scoping & Permissions

*   **App-Specific Context:** Communication between Sandboxes and MCP servers must securely identify the calling `appId`.
*   **Tool Authorization:** MCP Servers authorize tool requests based on `appId`, ensuring an application can only use permitted tools and access its own scoped resources (e.g., `core.state.*` calls).
*   **Credential Isolation:** Community MCP servers managing external service credentials must ensure strict isolation.

## 6.6 State Access Control (Via `StateManagerInterface`)

*   **`appId` Scoping:** All `StateManagerInterface` methods are strictly confined to the provided `appId`'s state repository or runtime namespace.
*   **Controlled Modifications:** `ApplyDefinitionDiff` with `expectedBaseRevision` provides optimistic concurrency control.

## 6.7 Authentication & Authorization (User/Service)

*   **User Authentication:** Integration with an authentication provider is needed to identify end-users.
*   **Context Propagation:** Authenticated user information (`userInfo`) is securely propagated to sandboxes.
*   **Authorization Checks:** Application logic can use `context.userInfo` for fine-grained authorization. Roles/permissions are defined in `SecurityConfig.userRoles`.
*   **Service Authentication:** Internal gRPC API calls between Core Framework components should use service-to-service authentication (e.g., mTLS).

## 6.8 Prompt Injection / LLM Security

*   **Prompt Injection:** Mitigate via careful input sanitization, robust prompt design (clear delimiters, strong system prompts, instructing LLM to disregard conflicting user instructions).
*   **Data Exposure:** Ensure prompts do not inadvertently include sensitive data unless explicitly authorized.
*   **Output Validation:** Use `outputFormat` and strict `outputSchema` validation on LLM responses. Sanitize LLM outputs before use in subsequent steps.

## 6.9 Secure Deployment

*   Secure the host OS, Docker environment, and network.
*   Protect Admin Panel access with strong authentication/authorization.
*   Regularly update all components, runtimes, and base images.
*   Implement robust logging and monitoring for security events.
