# 3.20 User Interface (UI)

## 3.20.1 Introduction

This section details the design principles and core components of the Nexus CoCreate AI user interface, focusing on the Minimum Viable Product (MVP) / Proof of Concept (POC) experience.

## 3.20.2 User Experience Goals

The paramount goal for the user experience (UX) is to be deeply intuitive, primarily chat-centric, and highly capable of abstracting underlying technical complexities. Users, regardless of their technical background, should feel as though they are collaborating with an intelligent, helpful partner (Nexus) rather than programming a complex machine.

*   **Chat-centricity:** The chat window is the primary medium for command, control, creation, and learning. It supports persistent context within a project.
*   **Abstraction of Complexity:** The interface hides technical details like package management or intricate API integrations, allowing users to focus on high-level goals.
*   **Adaptive Interface:** The interface should subtly adapt to the user's level of expertise, offering guided workflows for novices and exposing advanced options for power users.

## 3.20.3 MVP UI Components and Interactions

This section details the essential UI components and interaction paradigms for the Minimum Viable Product (MVP).

### 3.20.3.1 Primary Interface – The Nexus Chat Window

The cornerstone of user interaction is a persistent, context-aware chat window for natural language conversations with Nexus. Through this interface, users will:
*   Define and refine project goals and requirements.
*   Request Nexus to perform actions (create apps, generate code, summarize content, run projects).
*   Receive guidance, suggestions, and feedback from Nexus.
*   Troubleshoot issues and manage project settings.

For the MVP, text-based input is primary. The chat supports persistent context within a project.

### 3.20.3.2 The Canvas – A Dynamic Content Workspace

A versatile "canvas" area serves as the primary view for displaying and interacting with content generated by apps or Nexus. It adapts to the content type. For the MVP/POC, this includes:
*   **Viewing:** Text documents (plain text, Markdown with preview), source code (with basic syntax highlighting), simple image formats.
*   **Basic Edits:** Direct text edits for text/code. Simple image manipulations (cropping, basic adjustments, annotations). Ability to "Save As" or save annotated images.

The canvas provides a visually rich representation of data and allows manual control. Users can open a file in the canvas and initiate a discussion with Nexus about that specific content, with the active canvas item's context implicitly passed to Nexus.

### 3.20.3.3 Minimal Screens & Overlays

The UI is lean, avoiding a proliferation of complex screens. Most interactions flow through the chat and canvas. Contextual overlays may appear for specific, focused tasks (file version history, simple tool config pop-ups, confirmation dialogs). These are non-intrusive and quickly dismissible.

### 3.20.3.4 App Management Toolbar (POC Functionality)

When an app is selected or active, a simple, contextual toolbar provides essential buttons for core lifecycle actions:
*   **"Start":** Initiate execution of the app's defined start script in its Docker container.
*   **"Stop":** Terminate the running app container.
*   **"Restart":** Gracefully stop and then start the app container.

These actions provide clear visual feedback (status indicators, button changes, notifications).

### 3.20.3.5 Running App Interaction – Modality-Driven Presentation

Interaction with a "running" app depends on its nature:
*   **Conversational/Agentic Apps:** Run using the same agentic chat interface as Nexus, but operating strictly based on the app's defined logic. Clear visual cues indicate interaction with the app persona vs. the general Nexus assistant.
*   **Web-based Apps (POC Simplification):** Displayed via an embedded view (e.g., iframe) or by opening in a new browser tab. The AppDefinition may specify the preferred display method.
*   **CLI-based Apps (POC Simplification):** Interact via a basic "dummy shell" or text-based terminal-like interface within the app's container view on the canvas.

### 3.20.3.6 Switching Context Between App and Nexus

Users need a clear way to switch focus:
*   **Embedded Apps:** Nexus chat and project toolbar remain visible alongside the embedded app view.
*   **Separate Tab/Window Apps:** Standard browser tab switching returns to the main platform tab, which acts as the control panel for the project. A "Return to Project Management" button may be provided.

## 3.20.4 UI Generation for Applications

A key aspect of the Nexus CoCreate AI platform is the dynamic generation of user interfaces for deployed applications.

*   **Generation Mechanism:** For V1, the primary mechanism involves an LLM (either the main application LLM handler or a specialized UI-focused LLM invoked via an MCP tool or workflow step). Based on the application's `ApplicationDefinition`, `ComponentRegistry`, user requirements specified during bootstrapping, and potentially the context of the current request, the LLM generates standard web frontend code: HTML, CSS, and JavaScript.
*   **Simplicity Focus:** The initial focus is on generating functional, standard interfaces. Standard layouts, form elements, and basic interactivity driven by JavaScript making calls back to the application's backend endpoints (routed via the `RequestRouter`) are expected.
*   **State-Driven:** The UI structure and content should reflect the current state and capabilities defined in the `ComponentRegistry` and Workflow Definitions.
*   **Serving:** Generated static assets (HTML, CSS, JS files) or dynamically rendered HTML are served directly by the Nexus CoCreate AI Core Framework. The framework includes an integrated web server component.

## 3.20.5 Admin Panel

A functional Admin Panel is essential for managing the Nexus CoCreate AI platform and the applications it hosts.

### 3.20.5.1 Core Requirements (V1)

*   **Application Management:**
    *   UI for initiating the Application Bootstrap Process (creating new applications - see Section 3.16).
    *   Listing deployed applications with their status (via `ApplicationRegistryService.GetApplicationStatus`).
    *   Viewing application definitions (via `ApplicationRegistryService.GetApplicationDetails`).
    *   Triggering application updates (invoking `ApplicationRegistryService.UpdateApplication`).
    *   Activating/Deactivating or Deregistering applications (invoking `ApplicationRegistryService.DeregisterApplication`).
*   **Basic Monitoring:**
    *   Displaying key metrics from the `MetricCollector` (e.g., request counts, latency, error rates, LLM token usage per application).
*   **Optimization Control:**
    *   UI for viewing and configuring optimization rules (Global, Per-App, Per-Component) stored in `AppDefinition`.
    *   Displaying recommendations from the `OptimizationOracle`.
    *   Manually triggering JIT optimization for components.
*   **Configuration Management:**
    *   UI for managing global framework settings and potentially sensitive application configurations (e.g., API keys, with secure storage).
*   **State Viewing/Editing (Limited):**
    *   Potential for browsing or carefully editing YAML files in an application's definition state (via `StateManagerInterface`), primarily for debugging or advanced configuration.

The Admin Panel acts as the primary human interface for the platform's control plane, utilizing internal APIs like `ApplicationRegistryService`.
